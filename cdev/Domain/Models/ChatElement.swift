import Foundation

/// Shared filters for internal or non-user-facing chat content.
enum ChatContentFilter {
    /// Returns true when a message should be hidden from chat views.
    static func shouldHideInternalMessage(_ text: String) -> Bool {
        let trimmed = text.trimmingCharacters(in: .whitespacesAndNewlines)
        guard !trimmed.isEmpty else { return false }

        if trimmed.hasPrefix("Caveat: The messages below were generated by the user") {
            return true
        }

        let lower = trimmed.lowercased()
        if lower.contains("<local-command-caveat") || lower.contains("<local=command-caveat") {
            return true
        }

        return false
    }
}

// MARK: - Element Types (matching Elements API spec)

/// UI Element types from cdev-agent Elements API
/// These map directly to SwiftUI view components
enum ElementType: String, Codable {
    case userInput = "user_input"
    case assistantText = "assistant_text"
    case toolCall = "tool_call"
    case toolResult = "tool_result"
    case diff = "diff"
    case editDiff = "edit_diff"  // Edit tool with old_string vs new_string diff
    case thinking = "thinking"
    case interrupted = "interrupted"
    case contextCompaction = "context_compaction"  // Claude Code context window compacted
    case task = "task"  // Task tool use (Plan, Explore agents)
    case taskGroup = "task_group"  // Group of related tasks
}

/// Tool execution status
enum ToolStatus: String, Codable {
    case running
    case completed
    case error
    case interrupted
}

/// Diff line type for syntax highlighting (Elements API specific)
/// Note: Different from DiffLineType in DiffEntry.swift which uses addition/deletion
enum ElementDiffLineType: String, Codable, Equatable {
    case context
    case added
    case removed
}

// MARK: - Chat Element

/// UI-ready element for Terminal/Chat view
/// Matches the Elements API structure for future compatibility
struct ChatElement: Codable, Identifiable, Equatable {
    let id: String
    let type: ElementType
    let timestamp: Date
    let content: ElementContent

    init(id: String = UUID().uuidString, type: ElementType, timestamp: Date = Date(), content: ElementContent) {
        self.id = id
        self.type = type
        self.timestamp = timestamp
        self.content = content
    }

    enum CodingKeys: String, CodingKey {
        case id, type, timestamp, content
    }

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.id = try container.decode(String.self, forKey: .id)
        self.type = try container.decode(ElementType.self, forKey: .type)

        // Parse timestamp
        if let timestampStr = try? container.decode(String.self, forKey: .timestamp) {
            let formatter = ISO8601DateFormatter()
            formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
            self.timestamp = formatter.date(from: timestampStr) ?? Date()
        } else {
            self.timestamp = Date()
        }

        // Decode content based on type
        self.content = try ElementContent.decode(from: container, type: self.type)
    }
}

// MARK: - Element Content

/// Union type for element content
enum ElementContent: Codable, Equatable {
    case userInput(UserInputContent)
    case assistantText(AssistantTextContent)
    case toolCall(ToolCallContent)
    case toolResult(ToolResultContent)
    case diff(DiffContent)
    case editDiff(EditDiffContent)
    case thinking(ThinkingContent)
    case interrupted(InterruptedContent)
    case contextCompaction(ContextCompactionContent)
    case task(TaskContent)
    case taskGroup(TaskGroupContent)

    static func decode(from container: KeyedDecodingContainer<ChatElement.CodingKeys>, type: ElementType) throws -> ElementContent {
        let nestedDecoder = try container.superDecoder(forKey: .content)

        switch type {
        case .userInput:
            return .userInput(try UserInputContent(from: nestedDecoder))
        case .assistantText:
            return .assistantText(try AssistantTextContent(from: nestedDecoder))
        case .toolCall:
            return .toolCall(try ToolCallContent(from: nestedDecoder))
        case .toolResult:
            return .toolResult(try ToolResultContent(from: nestedDecoder))
        case .diff:
            return .diff(try DiffContent(from: nestedDecoder))
        case .editDiff:
            return .editDiff(try EditDiffContent(from: nestedDecoder))
        case .thinking:
            return .thinking(try ThinkingContent(from: nestedDecoder))
        case .interrupted:
            return .interrupted(try InterruptedContent(from: nestedDecoder))
        case .contextCompaction:
            return .contextCompaction(try ContextCompactionContent(from: nestedDecoder))
        case .task:
            return .task(try TaskContent(from: nestedDecoder))
        case .taskGroup:
            return .taskGroup(try TaskGroupContent(from: nestedDecoder))
        }
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        switch self {
        case .userInput(let content): try container.encode(content)
        case .assistantText(let content): try container.encode(content)
        case .toolCall(let content): try container.encode(content)
        case .toolResult(let content): try container.encode(content)
        case .diff(let content): try container.encode(content)
        case .editDiff(let content): try container.encode(content)
        case .thinking(let content): try container.encode(content)
        case .interrupted(let content): try container.encode(content)
        case .contextCompaction(let content): try container.encode(content)
        case .task(let content): try container.encode(content)
        case .taskGroup(let content): try container.encode(content)
        }
    }
}

// MARK: - Content Types

struct UserInputContent: Codable, Equatable {
    let text: String
}

struct AssistantTextContent: Codable, Equatable {
    let text: String
    let model: String?

    init(text: String, model: String? = nil) {
        self.text = text
        self.model = model
    }
}

struct ToolCallContent: Codable, Equatable {
    let tool: String
    let toolId: String?
    let display: String
    let params: [String: String]
    var status: ToolStatus
    var durationMs: Int?
    /// Full content for Write tool (not truncated)
    var fullContent: String?

    enum CodingKeys: String, CodingKey {
        case tool
        case toolId = "tool_id"
        case display
        case params
        case status
        case durationMs = "duration_ms"
        case fullContent = "full_content"
    }

    init(tool: String, toolId: String? = nil, display: String, params: [String: String] = [:], status: ToolStatus = .running, durationMs: Int? = nil, fullContent: String? = nil) {
        self.tool = tool
        self.toolId = toolId
        self.display = display
        self.params = params
        self.status = status
        self.durationMs = durationMs
        self.fullContent = fullContent
    }
}

struct ToolResultContent: Codable, Equatable {
    let toolCallId: String
    let toolName: String
    let isError: Bool
    let errorCode: Int?
    let summary: String
    let fullContent: String
    let lineCount: Int
    let expandable: Bool
    let truncated: Bool

    enum CodingKeys: String, CodingKey {
        case toolCallId = "tool_call_id"
        case toolName = "tool_name"
        case isError = "is_error"
        case errorCode = "error_code"
        case summary
        case fullContent = "full_content"
        case lineCount = "line_count"
        case expandable
        case truncated
    }

    init(
        toolCallId: String,
        toolName: String,
        isError: Bool = false,
        errorCode: Int? = nil,
        summary: String,
        fullContent: String,
        lineCount: Int? = nil,
        expandable: Bool = true,
        truncated: Bool = false
    ) {
        self.toolCallId = toolCallId
        self.toolName = toolName
        self.isError = isError
        self.errorCode = errorCode
        self.summary = summary
        self.fullContent = fullContent
        self.lineCount = lineCount ?? max(1, fullContent.components(separatedBy: "\n").count)
        self.expandable = expandable
        self.truncated = truncated
    }
}

struct DiffContent: Codable, Equatable {
    let toolCallId: String
    let filePath: String
    let summary: DiffSummary
    let hunks: [ElementDiffHunk]

    enum CodingKeys: String, CodingKey {
        case toolCallId = "tool_call_id"
        case filePath = "file_path"
        case summary
        case hunks
    }
}

struct DiffSummary: Codable, Equatable {
    let added: Int
    let removed: Int
    let display: String
}

struct ElementDiffHunk: Codable, Equatable, Identifiable {
    var id: String { header }

    let header: String
    let oldStart: Int
    let oldCount: Int
    let newStart: Int
    let newCount: Int
    let lines: [ElementDiffLine]

    enum CodingKeys: String, CodingKey {
        case header
        case oldStart = "old_start"
        case oldCount = "old_count"
        case newStart = "new_start"
        case newCount = "new_count"
        case lines
    }
}

struct ElementDiffLine: Codable, Equatable, Identifiable {
    var id: String { "\(oldLine ?? 0)-\(newLine ?? 0)-\(content.hashValue)" }

    let type: ElementDiffLineType
    let oldLine: Int?
    let newLine: Int?
    let content: String

    enum CodingKeys: String, CodingKey {
        case type
        case oldLine = "old_line"
        case newLine = "new_line"
        case content
    }
}

/// Edit tool diff content - shows comparison between old_string and new_string
/// Displays like Claude Code CLI with Update(file) header and line-by-line diff
struct EditDiffContent: Codable, Equatable {
    let toolCallId: String
    let filePath: String
    let addedLines: Int
    let removedLines: Int
    let lines: [EditDiffLine]
    var status: ToolStatus

    enum CodingKeys: String, CodingKey {
        case toolCallId = "tool_call_id"
        case filePath = "file_path"
        case addedLines = "added_lines"
        case removedLines = "removed_lines"
        case lines
        case status
    }

    init(
        toolCallId: String,
        filePath: String,
        oldString: String,
        newString: String,
        status: ToolStatus = .completed
    ) {
        self.toolCallId = toolCallId
        self.filePath = filePath
        self.status = status

        // Compute diff between old and new strings
        let (diffLines, added, removed) = Self.computeDiff(oldString: oldString, newString: newString)
        self.lines = diffLines
        self.addedLines = added
        self.removedLines = removed
    }

    /// Compute line-by-line diff between old and new strings
    /// Uses a simple LCS-based diff algorithm
    private static func computeDiff(oldString: String, newString: String) -> (lines: [EditDiffLine], added: Int, removed: Int) {
        let oldLines = oldString.components(separatedBy: "\n")
        let newLines = newString.components(separatedBy: "\n")

        var result: [EditDiffLine] = []
        var added = 0
        var removed = 0

        // Simple diff using longest common subsequence approach
        let lcs = longestCommonSubsequence(oldLines, newLines)

        var oldIdx = 0
        var newIdx = 0
        var oldLineNum = 1
        var newLineNum = 1

        for commonLine in lcs {
            // Output removed lines (in old but not at current position in new)
            while oldIdx < oldLines.count && oldLines[oldIdx] != commonLine {
                result.append(EditDiffLine(
                    type: .removed,
                    oldLine: oldLineNum,
                    newLine: nil,
                    content: oldLines[oldIdx]
                ))
                removed += 1
                oldIdx += 1
                oldLineNum += 1
            }

            // Output added lines (in new but not at current position in old)
            while newIdx < newLines.count && newLines[newIdx] != commonLine {
                result.append(EditDiffLine(
                    type: .added,
                    oldLine: nil,
                    newLine: newLineNum,
                    content: newLines[newIdx]
                ))
                added += 1
                newIdx += 1
                newLineNum += 1
            }

            // Output context line (common)
            result.append(EditDiffLine(
                type: .context,
                oldLine: oldLineNum,
                newLine: newLineNum,
                content: commonLine
            ))
            oldIdx += 1
            newIdx += 1
            oldLineNum += 1
            newLineNum += 1
        }

        // Output remaining removed lines
        while oldIdx < oldLines.count {
            result.append(EditDiffLine(
                type: .removed,
                oldLine: oldLineNum,
                newLine: nil,
                content: oldLines[oldIdx]
            ))
            removed += 1
            oldIdx += 1
            oldLineNum += 1
        }

        // Output remaining added lines
        while newIdx < newLines.count {
            result.append(EditDiffLine(
                type: .added,
                oldLine: nil,
                newLine: newLineNum,
                content: newLines[newIdx]
            ))
            added += 1
            newIdx += 1
            newLineNum += 1
        }

        return (result, added, removed)
    }

    /// Find longest common subsequence of two string arrays
    private static func longestCommonSubsequence(_ a: [String], _ b: [String]) -> [String] {
        let m = a.count
        let n = b.count

        // DP table
        var dp = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: m + 1)

        for i in 1...m {
            for j in 1...n {
                if a[i - 1] == b[j - 1] {
                    dp[i][j] = dp[i - 1][j - 1] + 1
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
                }
            }
        }

        // Backtrack to find LCS
        var result: [String] = []
        var i = m, j = n
        while i > 0 && j > 0 {
            if a[i - 1] == b[j - 1] {
                result.append(a[i - 1])
                i -= 1
                j -= 1
            } else if dp[i - 1][j] > dp[i][j - 1] {
                i -= 1
            } else {
                j -= 1
            }
        }

        return result.reversed()
    }
}

/// Individual line in an Edit diff
struct EditDiffLine: Codable, Equatable, Identifiable {
    /// Unique identifier - uses UUID for ellipsis lines, content-based for regular lines
    var id: String {
        if let uniqueId = uniqueId {
            return uniqueId
        }
        return "\(type.rawValue)-\(oldLine ?? 0)-\(newLine ?? 0)-\(content.hashValue)"
    }

    let type: ElementDiffLineType
    let oldLine: Int?
    let newLine: Int?
    let content: String
    /// Optional unique ID for ellipsis/gap lines to avoid duplicate IDs
    var uniqueId: String?

    enum CodingKeys: String, CodingKey {
        case type
        case oldLine = "old_line"
        case newLine = "new_line"
        case content
        case uniqueId = "unique_id"
    }

    init(type: ElementDiffLineType, oldLine: Int?, newLine: Int?, content: String, uniqueId: String? = nil) {
        self.type = type
        self.oldLine = oldLine
        self.newLine = newLine
        self.content = content
        self.uniqueId = uniqueId
    }
}

struct ThinkingContent: Codable, Equatable {
    let text: String
    var collapsed: Bool

    init(text: String, collapsed: Bool = true) {
        self.text = text
        self.collapsed = collapsed
    }
}

struct InterruptedContent: Codable, Equatable {
    let toolCallId: String
    let message: String

    enum CodingKeys: String, CodingKey {
        case toolCallId = "tool_call_id"
        case message
    }
}

/// Context compaction content - shown when Claude Code compacts conversation
/// This is auto-generated when context window reaches limit
struct ContextCompactionContent: Codable, Equatable {
    let summary: String       // The auto-generated summary text
    var isExpanded: Bool      // Whether to show full summary

    init(summary: String, isExpanded: Bool = false) {
        self.summary = summary
        self.isExpanded = isExpanded
    }
}

/// Task execution status for agent tasks (Plan, Explore, etc.)
enum TaskStatus: String, Codable, Equatable {
    case running
    case completed
    case failed
}

/// Individual task content - represents a single agent task execution
/// Matches Claude Code CLI Task display format
struct TaskContent: Codable, Equatable, Identifiable {
    let id: String              // Tool use ID
    let description: String     // Task description
    let agentType: String       // "Plan", "Explore", etc.
    let model: String?          // "sonnet", "haiku", etc.
    var status: TaskStatus      // Current execution status
    var toolUses: Int?          // Number of tool uses (from result)
    var tokens: Int?            // Token count (from usage)
    var agentId: String?        // Agent ID for resuming
    var inputTokens: Int?       // Input tokens
    var outputTokens: Int?      // Output tokens

    enum CodingKeys: String, CodingKey {
        case id, description
        case agentType = "agent_type"
        case model, status
        case toolUses = "tool_uses"
        case tokens
        case agentId = "agent_id"
        case inputTokens = "input_tokens"
        case outputTokens = "output_tokens"
    }

    init(
        id: String,
        description: String,
        agentType: String,
        model: String? = nil,
        status: TaskStatus = .running,
        toolUses: Int? = nil,
        tokens: Int? = nil,
        agentId: String? = nil,
        inputTokens: Int? = nil,
        outputTokens: Int? = nil
    ) {
        self.id = id
        self.description = description
        self.agentType = agentType
        self.model = model
        self.status = status
        self.toolUses = toolUses
        self.tokens = tokens
        self.agentId = agentId
        self.inputTokens = inputTokens
        self.outputTokens = outputTokens
    }
}

/// Task group content - represents a collapsible group of related tasks
/// Groups consecutive tasks by agent type (e.g., "3 Explore agents finished")
struct TaskGroupContent: Codable, Equatable, Identifiable {
    let id: String
    let agentType: String       // "Plan", "Explore", etc.
    let tasks: [TaskContent]    // Tasks in this group
    var isExpanded: Bool        // Expansion state

    var count: Int { tasks.count }
    var allCompleted: Bool { tasks.allSatisfy { $0.status == .completed } }
    var anyFailed: Bool { tasks.contains { $0.status == .failed } }

    enum CodingKeys: String, CodingKey {
        case id
        case agentType = "agent_type"
        case tasks
        case isExpanded = "is_expanded"
    }

    init(
        id: String = UUID().uuidString,
        agentType: String,
        tasks: [TaskContent],
        isExpanded: Bool = false
    ) {
        self.id = id
        self.agentType = agentType
        self.tasks = tasks
        self.isExpanded = isExpanded
    }
}

// MARK: - Factory Methods

extension ChatElement {
    /// Create from user prompt (optimistic display)
    /// Uses UUID for unique identification - server echoes are already skipped
    /// by isOurOwnPrompt() in DashboardViewModel, so content-based dedup is unnecessary
    static func userInput(_ text: String, sessionId: String? = nil) -> ChatElement {
        return ChatElement(
            id: UUID().uuidString,
            type: .userInput,
            content: .userInput(UserInputContent(text: text))
        )
    }

    /// Create from assistant text
    static func assistantText(_ text: String, model: String? = nil) -> ChatElement {
        ChatElement(
            type: .assistantText,
            content: .assistantText(AssistantTextContent(text: text, model: model))
        )
    }

    /// Create from tool call
    static func toolCall(
        tool: String,
        toolId: String? = nil,
        display: String,
        params: [String: String] = [:],
        status: ToolStatus = .running
    ) -> ChatElement {
        ChatElement(
            type: .toolCall,
            content: .toolCall(ToolCallContent(
                tool: tool,
                toolId: toolId,
                display: display,
                params: params,
                status: status
            ))
        )
    }

    /// Create from tool result
    static func toolResult(
        toolCallId: String,
        toolName: String,
        isError: Bool = false,
        summary: String,
        fullContent: String
    ) -> ChatElement {
        ChatElement(
            type: .toolResult,
            content: .toolResult(ToolResultContent(
                toolCallId: toolCallId,
                toolName: toolName,
                isError: isError,
                summary: summary,
                fullContent: fullContent
            ))
        )
    }

    /// Create thinking element
    static func thinking(_ text: String) -> ChatElement {
        ChatElement(
            type: .thinking,
            content: .thinking(ThinkingContent(text: text))
        )
    }

    /// Create context compaction element
    static func contextCompaction(summary: String) -> ChatElement {
        ChatElement(
            type: .contextCompaction,
            content: .contextCompaction(ContextCompactionContent(summary: summary))
        )
    }

    /// Create from ClaudeMessagePayload (WebSocket event)
    /// Supports both cdev-agent format (content at payload level) and API format (content in message)
    static func from(payload: ClaudeMessagePayload) -> [ChatElement] {
        var elements: [ChatElement] = []

        // Use unified accessors for role and content
        let effectiveRole = payload.effectiveRole
        guard let effectiveContent = payload.effectiveContent else { return elements }

        // Get model from payload or message level
        let model = payload.effectiveModel

        // Parse timestamp
        let timestamp: Date
        if let timestampStr = payload.timestamp {
            let formatter = ISO8601DateFormatter()
            formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
            timestamp = formatter.date(from: timestampStr) ?? Date()
        } else {
            timestamp = Date()
        }

        // Check for context compaction first (marked by is_context_compaction field)
        if payload.isContextCompaction == true {
            let text = effectiveContent.textContent
            // Skip system "Conversation compacted" message, only show user summary
            if effectiveRole == "user" && !text.isEmpty {
                elements.append(ChatElement(
                    id: payload.uuid ?? UUID().uuidString,
                    type: .contextCompaction,
                    timestamp: timestamp,
                    content: .contextCompaction(ContextCompactionContent(summary: text))
                ))
            }
            // Return early - don't process as regular message
            return elements
        }

        // Skip internal Claude Code caveat messages (not user-facing)
        let textContent = effectiveContent.textContent
        if ChatContentFilter.shouldHideInternalMessage(textContent) {
            return elements
        }

        // User message - may be simple text or contain tool_result blocks
        if effectiveRole == "user" {
            // Use timestamp-based ID for deduplication when uuid is nil
            // Same content + same timestamp = deduplicated (streaming duplicates)
            // Same content + different timestamp = both shown (repeated commands)
            let baseId = payload.uuid ?? generateTimestampBasedId(role: "user", text: textContent, timestamp: payload.timestamp)

            switch effectiveContent {
            case .text(let text):
                // Simple text input
                if !text.isEmpty {
                    elements.append(ChatElement(
                        id: baseId,
                        type: .userInput,
                        timestamp: timestamp,
                        content: .userInput(UserInputContent(text: text))
                    ))
                }

            case .blocks(let blocks):
                for (index, block) in blocks.enumerated() {
                    let blockId = block.effectiveId.isEmpty ? "\(baseId)-\(index)" : block.effectiveId

                    switch block.type {
                    case "tool_result":
                        // Tool result in user message (e.g., Bash output)
                        if let element = createToolResultElement(from: block, blockId: blockId, timestamp: timestamp) {
                            elements.append(element)
                        }

                    case "text":
                        // Text block in user message
                        if let text = block.text, !text.isEmpty {
                            elements.append(ChatElement(
                                id: "\(baseId)-text-\(index)",
                                type: .userInput,
                                timestamp: timestamp,
                                content: .userInput(UserInputContent(text: text))
                            ))
                        }

                    default:
                        // Unknown block type - treat as text if has content
                        if let text = block.text ?? block.content, !text.isEmpty {
                            elements.append(ChatElement(
                                id: "\(baseId)-\(index)",
                                type: .userInput,
                                timestamp: timestamp,
                                content: .userInput(UserInputContent(text: text))
                            ))
                        }
                    }
                }
            }
            return elements
        }

        // Assistant message - may have multiple content blocks
        // Use timestamp-based ID for deduplication when uuid is nil
        // Same content + same timestamp = deduplicated (streaming duplicates)
        // Same content + different timestamp = both shown (different responses)
        let baseId = payload.uuid ?? generateTimestampBasedId(role: "assistant", text: effectiveContent.textContent, timestamp: payload.timestamp)

        switch effectiveContent {
        case .text(let text):
            if !text.isEmpty {
                elements.append(ChatElement(
                    id: "\(baseId)-text-0",
                    type: .assistantText,
                    timestamp: timestamp,
                    content: .assistantText(AssistantTextContent(text: text, model: model))
                ))
            }

        case .blocks(let blocks):
            for (index, block) in blocks.enumerated() {
                let blockId = block.effectiveId

                switch block.type {
                case "text":
                    if let text = block.text, !text.isEmpty {
                        // Use baseId + index for unique ID (text blocks may not have unique IDs)
                        let textId = "\(baseId)-text-\(index)"
                        elements.append(ChatElement(
                            id: textId,
                            type: .assistantText,
                            timestamp: timestamp,
                            content: .assistantText(AssistantTextContent(text: text, model: model))
                        ))
                    }

                case "thinking":
                    if let text = block.text, !text.isEmpty {
                        // Use baseId + index for unique ID
                        let thinkingId = "\(baseId)-thinking-\(index)"
                        elements.append(ChatElement(
                            id: thinkingId,
                            type: .thinking,
                            timestamp: timestamp,
                            content: .thinking(ThinkingContent(text: text))
                        ))
                    }

                case "tool_use":
                    // Use unified accessors for tool name and input
                    let toolName = block.effectiveName ?? "tool"
                    var params: [String: String] = [:]
                    if let input = block.effectiveInput {
                        for (key, value) in input {
                            params[key] = value.stringValue
                        }
                    }

                    // Check if this is a Task tool - special handling for agents
                    if toolName == "Task" {
                        let description = params["description"] ?? "Task"
                        let agentType = params["subagent_type"] ?? "agent"
                        let modelStr = params["model"]

                        elements.append(ChatElement(
                            id: blockId,
                            type: .task,
                            timestamp: timestamp,
                            content: .task(TaskContent(
                                id: block.effectiveId,
                                description: description,
                                agentType: agentType,
                                model: modelStr,
                                status: .running,
                                inputTokens: nil,
                                outputTokens: nil
                            ))
                        ))
                    }
                    // Check if this is an Edit tool - display as diff view
                    else if toolName == "Edit",
                       let filePath = params["file_path"],
                       let oldString = params["old_string"],
                       let newString = params["new_string"] {
                        // Create EditDiff element for visual diff display
                        elements.append(ChatElement(
                            id: blockId,
                            type: .editDiff,
                            timestamp: timestamp,
                            content: .editDiff(EditDiffContent(
                                toolCallId: block.effectiveId,
                                filePath: filePath,
                                oldString: oldString,
                                newString: newString,
                                status: .completed
                            ))
                        ))
                    } else {
                        // Create display string for other tools
                        let display = formatToolDisplay(tool: toolName, params: params)

                        // For Write tool, capture full content
                        let fullContent = (toolName == "Write") ? params["content"] : nil

                        elements.append(ChatElement(
                            id: blockId,
                            type: .toolCall,
                            timestamp: timestamp,
                            content: .toolCall(ToolCallContent(
                                tool: toolName,
                                toolId: block.effectiveId,
                                display: display,
                                params: params,
                                status: .completed,
                                fullContent: fullContent
                            ))
                        ))
                    }

                case "tool_result":
                    if let element = createToolResultElement(from: block, blockId: blockId, timestamp: timestamp) {
                        elements.append(element)
                    }

                default:
                    break
                }
            }
        }

        return elements
    }

    /// Create from LogEntry (legacy format)
    /// Note: claude_log events are plain text - we preserve them as-is without aggressive pattern matching
    static func from(logEntry: LogEntry) -> ChatElement {
        let text = logEntry.content

        // Only detect user input (starts with > or ❯ prompt)
        if logEntry.stream == .user || text.hasPrefix("> ") || text.hasPrefix("❯ ") {
            let userText = text
                .trimmingCharacters(in: CharacterSet.whitespaces)
                .replacingOccurrences(of: "^[>❯]\\s*", with: "", options: .regularExpression)
            return ChatElement(
                id: logEntry.id,
                type: .userInput,
                timestamp: logEntry.timestamp,
                content: .userInput(UserInputContent(text: userText))
            )
        }

        // Stderr goes as error/tool result
        if logEntry.stream == .stderr {
            return ChatElement(
                id: logEntry.id,
                type: .toolResult,
                timestamp: logEntry.timestamp,
                content: .toolResult(ToolResultContent(
                    toolCallId: "",
                    toolName: "",
                    isError: true,
                    summary: text,
                    fullContent: text
                ))
            )
        }

        // System messages
        if logEntry.stream == .system {
            return ChatElement(
                id: logEntry.id,
                type: .assistantText,
                timestamp: logEntry.timestamp,
                content: .assistantText(AssistantTextContent(text: text))
            )
        }

        // Default: treat as assistant text (plain stdout from claude_log)
        // Don't try to parse tool calls from plain text - that's for structured claude_message events
        return ChatElement(
            id: logEntry.id,
            type: .assistantText,
            timestamp: logEntry.timestamp,
            content: .assistantText(AssistantTextContent(text: text))
        )
    }
}

// MARK: - Helper Functions

/// Create a ChatElement for tool_result from a content block
/// Used by both user message (Bash output) and assistant message parsing
private func createToolResultElement(from block: ClaudeMessagePayload.ContentBlock, blockId: String, timestamp: Date) -> ChatElement? {
    let resultContent = block.content ?? block.text ?? ""
    let isError = block.isError ?? false
    let lines = resultContent.components(separatedBy: "\n")
    let summary = lines.prefix(3).joined(separator: "\n")

    // Use tool_use_id + "-result" suffix to avoid collision with tool_use element
    let toolResultId = (block.toolUseId ?? blockId) + "-result"

    return ChatElement(
        id: toolResultId,
        type: .toolResult,
        timestamp: timestamp,
        content: .toolResult(ToolResultContent(
            toolCallId: block.toolUseId ?? "",
            toolName: block.effectiveName ?? "",
            isError: isError,
            summary: summary,
            fullContent: resultContent
        ))
    )
}

private func formatToolDisplay(tool: String, params: [String: String]) -> String {
    switch tool {
    case "Bash":
        if let cmd = params["command"] {
            let truncated = cmd.count > 60 ? String(cmd.prefix(60)) + "..." : cmd
            return "\(tool)(\(truncated))"
        }
    case "Read", "Write":
        if let path = params["file_path"] {
            return "\(tool)(\(path))"
        }
    case "Edit":
        if let path = params["file_path"] {
            return "\(tool)(\(path))"
        }
    case "Glob", "Grep":
        if let pattern = params["pattern"] {
            return "\(tool)(pattern: \"\(pattern)\")"
        }
    default:
        break
    }

    // Generic fallback
    let paramStr = params.map { "\($0.key): \($0.value)" }.joined(separator: ", ")
    if paramStr.isEmpty {
        return tool
    }
    return "\(tool)(\(paramStr.prefix(50)))"
}

/// Create ChatElements from session message (history API)
/// This properly handles Edit tools to show diff view instead of raw tool_result
/// Returns (elements, editToolIds) - editToolIds is used to filter corresponding tool_results
extension ChatElement {
    static func from(sessionMessage: SessionMessagesResponse.SessionMessage) -> (elements: [ChatElement], editToolIds: Set<String>) {
        var elements: [ChatElement] = []
        var editToolIds: Set<String> = []

        // Parse timestamp
        let timestamp: Date
        if let timestampStr = sessionMessage.timestamp {
            let formatter = ISO8601DateFormatter()
            formatter.formatOptions = [.withInternetDateTime, .withFractionalSeconds]
            timestamp = formatter.date(from: timestampStr) ?? Date()
        } else {
            timestamp = Date()
        }

        let baseId = sessionMessage.uuid ?? sessionMessage.id

        guard let content = sessionMessage.message.content else {
            return (elements, editToolIds)
        }

        if ChatContentFilter.shouldHideInternalMessage(sessionMessage.textContent) {
            return (elements, editToolIds)
        }

        switch content {
        case .string(let text):
            if !text.isEmpty {
                if sessionMessage.type == "user" {
                    elements.append(ChatElement(
                        id: "\(baseId)-text-0",
                        type: .userInput,
                        timestamp: timestamp,
                        content: .userInput(UserInputContent(text: text))
                    ))
                } else {
                    elements.append(ChatElement(
                        id: "\(baseId)-text-0",
                        type: .assistantText,
                        timestamp: timestamp,
                        content: .assistantText(AssistantTextContent(text: text, model: sessionMessage.message.model))
                    ))
                }
            }

        case .blocks(let blocks):
            for (index, block) in blocks.enumerated() {
                let blockId = block.id ?? block.toolUseId ?? "\(baseId)-\(index)"

                switch block.type {
                case "text":
                    if let text = block.text, !text.isEmpty {
                        if sessionMessage.type == "user" {
                            elements.append(ChatElement(
                                id: "\(baseId)-text-\(index)",
                                type: .userInput,
                                timestamp: timestamp,
                                content: .userInput(UserInputContent(text: text))
                            ))
                        } else {
                            elements.append(ChatElement(
                                id: "\(baseId)-text-\(index)",
                                type: .assistantText,
                                timestamp: timestamp,
                                content: .assistantText(AssistantTextContent(text: text, model: sessionMessage.message.model))
                            ))
                        }
                    }

                case "thinking":
                    if let text = block.text, !text.isEmpty {
                        elements.append(ChatElement(
                            id: "\(baseId)-thinking-\(index)",
                            type: .thinking,
                            timestamp: timestamp,
                            content: .thinking(ThinkingContent(text: text))
                        ))
                    }

                case "tool_use":
                    let toolName = block.name ?? "tool"

                    // Extract params from input dictionary
                    var params: [String: String] = [:]
                    if let input = block.input {
                        for (key, value) in input {
                            params[key] = value.stringValue
                        }
                    }

                    // Check if this is an Edit tool - display as diff view
                    if toolName == "Edit",
                       let filePath = params["file_path"],
                       let oldString = params["old_string"],
                       let newString = params["new_string"] {
                        // Track this Edit tool ID to filter its tool_result later
                        editToolIds.insert(blockId)

                        elements.append(ChatElement(
                            id: blockId,
                            type: .editDiff,
                            timestamp: timestamp,
                            content: .editDiff(EditDiffContent(
                                toolCallId: blockId,
                                filePath: filePath,
                                oldString: oldString,
                                newString: newString,
                                status: .completed
                            ))
                        ))
                    } else {
                        // Regular tool call
                        let display = formatToolDisplay(tool: toolName, params: params)

                        // For Write tool, capture full content
                        let fullContent = (toolName == "Write") ? params["content"] : nil

                        elements.append(ChatElement(
                            id: blockId,
                            type: .toolCall,
                            timestamp: timestamp,
                            content: .toolCall(ToolCallContent(
                                tool: toolName,
                                toolId: blockId,
                                display: display,
                                params: params,
                                status: .completed,
                                fullContent: fullContent
                            ))
                        ))
                    }

                case "tool_result":
                    // Will be filtered at the call site if it's an Edit tool_result
                    let resultContent = block.content ?? block.text ?? ""
                    let isError = block.isError ?? false
                    let lines = resultContent.components(separatedBy: "\n")
                    let summary = lines.prefix(3).joined(separator: "\n")
                    let toolResultId = (block.toolUseId ?? blockId) + "-result"

                    elements.append(ChatElement(
                        id: toolResultId,
                        type: .toolResult,
                        timestamp: timestamp,
                        content: .toolResult(ToolResultContent(
                            toolCallId: block.toolUseId ?? "",
                            toolName: block.name ?? "",
                            isError: isError,
                            summary: summary,
                            fullContent: resultContent
                        ))
                    ))

                default:
                    break
                }
            }
        }

        return (elements, editToolIds)
    }
}

/// Generate a deterministic ID based on message content and timestamp
/// Used when WebSocket events don't include a uuid field
/// Deduplicates: same content + same timestamp = same ID (streaming duplicates)
/// Differentiates: same content + different timestamp = different ID (repeated commands)
private func generateTimestampBasedId(role: String, text: String, timestamp: String?) -> String {
    let contentPrefix = String(text.prefix(100))
    // Include timestamp in hash so same content at different times gets different IDs
    let hashInput = "\(role):\(timestamp ?? ""):\(contentPrefix)"
    let hash = abs(hashInput.hashValue)
    return "ts-\(role)-\(hash)"
}
