import SwiftUI

// MARK: - Element Container View

/// Main container view that renders any ChatElement type
/// Matches Claude Code CLI visual style
struct ElementView: View {
    let element: ChatElement
    let showTimestamp: Bool
    var searchText: String = ""
    var isCurrentMatch: Bool = false
    var isMatch: Bool = false

    init(element: ChatElement, showTimestamp: Bool = false, searchText: String = "", isCurrentMatch: Bool = false, isMatch: Bool = false) {
        self.element = element
        self.showTimestamp = showTimestamp
        self.searchText = searchText
        self.isCurrentMatch = isCurrentMatch
        self.isMatch = isMatch
    }

    /// Check if this element should be hidden (internal Claude Code messages or empty bash output)
    private var shouldHide: Bool {
        if case .userInput(let content) = element.content {
            // Hide internal Claude Code messages
            if content.text.hasPrefix("Caveat: The messages below were generated by the user") {
                return true
            }
            // Hide messages with only empty bash-stdout/bash-stderr tags (no bash-input, no content)
            if isOnlyEmptyBashOutput(content.text) {
                return true
            }
        }
        return false
    }

    /// Check if text contains only empty bash output tags with no actual content
    private func isOnlyEmptyBashOutput(_ text: String) -> Bool {
        // Pattern to match bash-stdout and bash-stderr tags
        let bashOutputPattern = #"<(bash-stdout|bash-stderr)>([\s\S]*?)</\1>"#
        guard let regex = try? NSRegularExpression(pattern: bashOutputPattern, options: []) else {
            return false
        }

        var remaining = text
        var hasBashOutputTags = false
        var hasBashOutputContent = false
        var hasBashInput = false

        // Check for bash-input tag
        if text.contains("<bash-input>") {
            hasBashInput = true
        }

        // Check all bash output tags
        let matches = regex.matches(in: remaining, options: [], range: NSRange(remaining.startIndex..., in: remaining))
        for match in matches {
            hasBashOutputTags = true
            if let contentRange = Range(match.range(at: 2), in: remaining) {
                let content = String(remaining[contentRange])
                if !content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                    hasBashOutputContent = true
                    break
                }
            }
        }

        // Remove all bash tags to see if there's any other content
        remaining = remaining
            .replacingOccurrences(of: #"<bash-input>[\s\S]*?</bash-input>"#, with: "", options: .regularExpression)
            .replacingOccurrences(of: #"<bash-stdout>[\s\S]*?</bash-stdout>"#, with: "", options: .regularExpression)
            .replacingOccurrences(of: #"<bash-stderr>[\s\S]*?</bash-stderr>"#, with: "", options: .regularExpression)
            .trimmingCharacters(in: .whitespacesAndNewlines)

        // Hide if: we have bash output tags, no bash input, no content, and no other text
        return !hasBashInput && hasBashOutputTags && !hasBashOutputContent && remaining.isEmpty
    }

    var body: some View {
        // Hide internal Claude Code messages completely (no timestamp, no space)
        if shouldHide {
            EmptyView()
        } else {
            elementRow
        }
    }

    /// Check if this element type should hide timestamp (tool results are inline with tool calls)
    private var shouldHideTimestamp: Bool {
        switch element.content {
        case .toolResult:
            return true  // Tool results show inline with tool calls, no separate timestamp
        default:
            return false
        }
    }

    private var elementRow: some View {
        HStack(alignment: .top, spacing: Spacing.xs) {
            // Timestamp (optional) - aligned with content's first line
            // Hide timestamp for tool results (they're inline with tool calls)
            if showTimestamp && !shouldHideTimestamp {
                Text(formattedTime)
                    .font(Typography.terminalTimestamp)
                    .foregroundStyle(ColorSystem.textQuaternary)
                    .frame(width: 56, alignment: .trailing)
                    .padding(.top, 5)  // Align with status dot padding in element views
            } else if showTimestamp && shouldHideTimestamp {
                // Empty spacer to maintain alignment with other rows
                Spacer()
                    .frame(width: 56)
            }

            // Element content - let content determine height, ensure minimum visibility
            elementContent
                .frame(maxWidth: .infinity, alignment: .leading)
                .fixedSize(horizontal: false, vertical: true)
        }
        .frame(minHeight: 20)
        // Highlight background for search matches
        .background(
            RoundedRectangle(cornerRadius: 4)
                .fill(matchBackgroundColor)
        )
        // Border for current match
        .overlay(
            RoundedRectangle(cornerRadius: 4)
                .stroke(isCurrentMatch ? ColorSystem.warning : .clear, lineWidth: 2)
        )
        // Context menu for copy functionality
        .contextMenu {
            if let text = copyableText, !text.isEmpty {
                Button {
                    // Use async for large content to avoid blocking main thread
                    if text.count > 50_000 {
                        Task { @MainActor in
                            UIPasteboard.general.string = text
                            CopyToastManager.shared.show()
                        }
                    } else {
                        UIPasteboard.general.string = text
                        CopyToastManager.shared.show()
                    }
                    Haptics.selection()
                } label: {
                    Label("Copy", systemImage: "doc.on.doc")
                }
            }
        }
    }

    /// Text content for copy functionality
    /// Returns the relevant text based on element type
    private var copyableText: String? {
        switch element.content {
        case .userInput(let content):
            return content.text
        case .assistantText(let content):
            return content.text
        case .toolCall(let content):
            let params = content.params.map { "\($0.key): \($0.value)" }.joined(separator: ", ")
            return "\(content.tool)(\(params))"
        case .toolResult(let content):
            return content.fullContent
        case .thinking(let content):
            return content.text
        case .diff(let content):
            return content.hunks.flatMap { $0.lines.map { $0.content } }.joined(separator: "\n")
        case .editDiff(let content):
            return content.lines.map { line in
                let prefix = line.type == .added ? "+" : (line.type == .removed ? "-" : " ")
                return "\(prefix) \(line.content)"
            }.joined(separator: "\n")
        case .interrupted(let content):
            return content.message
        case .contextCompaction(let content):
            return content.summary
        case .task(let content):
            return content.description
        case .taskGroup(let content):
            return content.tasks.map { $0.description }.joined(separator: "\n")
        }
    }

    /// Background color for search matches
    private var matchBackgroundColor: Color {
        if isCurrentMatch {
            return ColorSystem.warning.opacity(0.2)
        } else if isMatch {
            return ColorSystem.warning.opacity(0.08)
        }
        return .clear
    }

    @ViewBuilder
    private var elementContent: some View {
        switch element.content {
        case .userInput(let content):
            UserInputElementView(content: content, searchText: searchText)

        case .assistantText(let content):
            AssistantTextElementView(content: content, searchText: searchText)

        case .toolCall(let content):
            // Legacy support: Display old Task toolCall elements with new Task UI
            if content.tool == "Task" {
                let taskContent = TaskContent(
                    id: content.toolId ?? "unknown",
                    description: content.params["description"] ?? content.params["prompt"] ?? "Task",
                    agentType: content.params["subagent_type"] ?? "agent",
                    model: content.params["model"],
                    status: .running,
                    toolUses: nil,
                    tokens: nil,
                    agentId: nil,
                    inputTokens: nil,
                    outputTokens: nil
                )
                TaskElementView(content: taskContent, searchText: searchText)
            }
            // Enhanced Write tool display with content preview
            else if content.tool == "Write", content.fullContent != nil {
                WriteToolElementView(content: content, searchText: searchText)
            } else {
                ToolCallElementView(content: content, searchText: searchText)
            }

        case .toolResult(let content):
            ToolResultElementView(content: content, searchText: searchText)

        case .diff(let content):
            DiffElementView(content: content)

        case .editDiff(let content):
            EditDiffElementView(content: content, searchText: searchText)

        case .thinking(let content):
            ThinkingElementView(content: content, searchText: searchText)

        case .interrupted(let content):
            InterruptedElementView(content: content)

        case .contextCompaction(let content):
            ContextCompactionElementView(content: content)

        case .task(let content):
            TaskElementView(content: content, searchText: searchText)

        case .taskGroup(let content):
            TaskGroupElementView(content: content, searchText: searchText)
        }
    }

    private var formattedTime: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "HH:mm:ss"
        return formatter.string(from: element.timestamp)
    }
}

// MARK: - User Input View

/// User prompt display: > user text
/// Also handles bash/git command tags with special formatting
struct UserInputElementView: View {
    let content: UserInputContent
    var searchText: String = ""

    /// Parsed segments from content (bash commands, output, regular text)
    private var segments: [BashSegment] {
        parseBashTags(from: content.text)
    }

    var body: some View {
        // Check if this is a special bash/command message
        if segments.isEmpty {
            // Empty segments (e.g., only empty bash-stdout/bash-stderr tags) - render nothing
            EmptyView()
        } else if segments.count == 1, case .text(let text) = segments[0], text == content.text {
            // Regular user input - display with > prompt
            regularUserInputView
        } else {
            // Has bash/command tags - display with special formatting
            VStack(alignment: .leading, spacing: 2) {
                ForEach(Array(segments.enumerated()), id: \.offset) { _, segment in
                    switch segment {
                    case .bashInput(let command):
                        BashInputSegmentView(command: command, searchText: searchText)
                    case .bashStdout(let output):
                        BashOutputSegmentView(output: output, isError: false, searchText: searchText)
                    case .bashStderr(let output):
                        if !output.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                            BashOutputSegmentView(output: output, isError: true, searchText: searchText)
                        }
                    case .localCommandStdout(let output):
                        LocalCommandOutputView(output: output, searchText: searchText)
                    case .commandMessage(let name, let message):
                        CommandMessageView(name: name, message: message, searchText: searchText)
                    case .text(let text):
                        if !text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                            regularTextView(text)
                        }
                    case .noContent:
                        BashNoContentView()
                    }
                }
            }
            .padding(.vertical, Spacing.xxs)
            .frame(minHeight: 20)
        }
    }

    private var regularUserInputView: some View {
        userTextRow(content.text)
            .padding(.vertical, Spacing.xxs)
            .frame(minHeight: 20)
    }

    @ViewBuilder
    private func regularTextView(_ text: String) -> some View {
        userTextRow(text)
    }

    /// Shared view for user text with ">" or "!" prompt and search highlighting
    /// Bash commands (starting with "!") show "!" prompt in green
    @ViewBuilder
    private func userTextRow(_ text: String) -> some View {
        let isBashCommand = text.hasPrefix("!")
        let promptSymbol = isBashCommand ? "!" : ">"
        let promptColor = isBashCommand ? ColorSystem.success : ColorSystem.Log.user
        // Strip leading "!" from text if it's a bash command (we show it as prompt symbol)
        let displayText = isBashCommand ? String(text.dropFirst()).trimmingCharacters(in: .whitespaces) : text

        HStack(alignment: .top, spacing: Spacing.xxs) {
            Text(promptSymbol)
                .font(Typography.terminal)
                .foregroundStyle(promptColor)
                .fontWeight(.bold)

            if searchText.isEmpty {
                Text(displayText)
                    .font(Typography.terminal)
                    .foregroundStyle(ColorSystem.Log.user)
                    .textSelection(.enabled)
                    .fixedSize(horizontal: false, vertical: true)
            } else {
                HighlightedText(displayText, highlighting: searchText)
                    .font(Typography.terminal)
                    .foregroundStyle(ColorSystem.Log.user)
                    .textSelection(.enabled)
                    .fixedSize(horizontal: false, vertical: true)
            }

            Spacer(minLength: 0)
        }
    }

    /// Parse text for bash-related tags
    private func parseBashTags(from text: String) -> [BashSegment] {
        var segments: [BashSegment] = []
        var remaining = text
        var hasBashInput = false
        var hasBashOutputTags = false  // Track if we have any bash output tags (even if empty)
        var hasBashOutputContent = false  // Track if we have any non-empty bash output

        // Combined pattern for all tags
        let combinedPattern = #"<(bash-input|bash-stdout|bash-stderr|local-command-stdout|command-name)>([\s\S]*?)</\1>"#
        guard let regex = try? NSRegularExpression(pattern: combinedPattern, options: []) else {
            return [.text(text)]
        }

        while let match = regex.firstMatch(in: remaining, options: [], range: NSRange(remaining.startIndex..., in: remaining)) {
            // Text before the tag
            if let beforeRange = Range(NSRange(location: 0, length: match.range.location), in: remaining) {
                let beforeText = String(remaining[beforeRange])
                if !beforeText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                    segments.append(.text(beforeText))
                }
            }

            // Extract tag name and content
            if let tagRange = Range(match.range(at: 1), in: remaining),
               let contentRange = Range(match.range(at: 2), in: remaining) {
                let tagName = String(remaining[tagRange])
                let content = String(remaining[contentRange])

                switch tagName {
                case "bash-input":
                    hasBashInput = true
                    segments.append(.bashInput(content))
                case "bash-stdout":
                    hasBashOutputTags = true
                    // Skip empty stdout to avoid empty ⎿ lines
                    if !content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                        hasBashOutputContent = true
                        segments.append(.bashStdout(content))
                    }
                case "bash-stderr":
                    hasBashOutputTags = true
                    // Skip empty stderr to avoid empty ⎿ lines
                    if !content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                        hasBashOutputContent = true
                        segments.append(.bashStderr(content))
                    }
                case "local-command-stdout":
                    // Strip ANSI codes from local command output
                    let cleanContent = content.replacingOccurrences(of: #"\u001b\[[0-9;]*m"#, with: "", options: .regularExpression)
                    segments.append(.localCommandStdout(cleanContent))
                case "command-name":
                    // Look for command-message that follows
                    let afterMatch = String(remaining[Range(match.range, in: remaining)!.upperBound...])
                    let msgPattern = #"<command-message>([\s\S]*?)</command-message>"#
                    if let msgRegex = try? NSRegularExpression(pattern: msgPattern),
                       let msgResult = msgRegex.firstMatch(in: afterMatch, range: NSRange(afterMatch.startIndex..., in: afterMatch)),
                       let msgContentRange = Range(msgResult.range(at: 1), in: afterMatch) {
                        let msgContent = String(afterMatch[msgContentRange])
                        segments.append(.commandMessage(name: content, message: msgContent))
                    }
                default:
                    break
                }
            }

            // Move past this match
            if let matchRange = Range(match.range, in: remaining) {
                remaining = String(remaining[matchRange.upperBound...])
            } else {
                break
            }
        }

        // Any remaining text
        if !remaining.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            // Skip if it's just leftover command tags
            let cleanRemaining = remaining
                .replacingOccurrences(of: #"<command-message>[\s\S]*?</command-message>"#, with: "", options: .regularExpression)
                .replacingOccurrences(of: #"<command-args>[\s\S]*?</command-args>"#, with: "", options: .regularExpression)
                .trimmingCharacters(in: .whitespacesAndNewlines)
            if !cleanRemaining.isEmpty {
                segments.append(.text(cleanRemaining))
            }
        }

        // If we have bash input but no output content, show "(No content)"
        // Only show "(No content)" when there's an actual bash command without output
        // Skip entirely if we only have empty bash-stdout/bash-stderr tags (no bash-input)
        if hasBashInput && !hasBashOutputContent {
            segments.append(.noContent)
        }

        // If we only have empty bash output tags (no bash-input, no other content),
        // return empty to skip rendering this message entirely
        if !hasBashInput && hasBashOutputTags && !hasBashOutputContent && segments.isEmpty {
            return []  // Return empty to indicate nothing to render
        }

        return segments.isEmpty ? [.text(text)] : segments
    }
}

/// Segment type for parsed bash content
private enum BashSegment {
    case bashInput(String)
    case bashStdout(String)
    case bashStderr(String)
    case localCommandStdout(String)
    case commandMessage(name: String, message: String)
    case text(String)
    case noContent  // Empty bash output - displays "(No content)" like CLI
}

// MARK: - Bash Input Segment View

/// Displays bash command with "!" prefix (Claude Code CLI style)
private struct BashInputSegmentView: View {
    let command: String
    var searchText: String = ""

    var body: some View {
        HStack(alignment: .top, spacing: Spacing.xxs) {
            // Bash indicator (Claude Code style)
            Text("!")
                .font(Typography.terminal)
                .foregroundStyle(ColorSystem.Bash.prompt)
                .fontWeight(.bold)

            // Command with search highlighting
            if searchText.isEmpty {
                Text(command)
                    .font(Typography.terminal)
                    .foregroundStyle(ColorSystem.Bash.command)
                    .textSelection(.enabled)
                    .fixedSize(horizontal: false, vertical: true)
            } else {
                HighlightedText(command, highlighting: searchText)
                    .font(Typography.terminal)
                    .foregroundStyle(ColorSystem.Bash.command)
                    .textSelection(.enabled)
                    .fixedSize(horizontal: false, vertical: true)
            }

            Spacer(minLength: 0)
        }
        .frame(minHeight: 20)
    }
}

// MARK: - Bash No Content View

/// Displays "(No content)" when bash command has empty output
/// Styled like Claude Code CLI with tree line prefix
private struct BashNoContentView: View {
    var body: some View {
        HStack(alignment: .top, spacing: Spacing.xxs) {
            // Tree line prefix (same as bash output)
            Text("⎿")
                .font(Typography.terminal)
                .foregroundStyle(ColorSystem.textQuaternary)

            Text("(No content)")
                .font(Typography.terminal)
                .foregroundStyle(ColorSystem.textQuaternary)
                .italic()
        }
    }
}

// MARK: - Bash Output Segment View

/// Collapsible bash output (stdout/stderr)
private struct BashOutputSegmentView: View {
    let output: String
    let isError: Bool
    var searchText: String = ""
    @State private var isExpanded = false

    private let previewLineCount = 5

    private var lines: [String] {
        output.components(separatedBy: "\n")
    }

    private var hasMoreLines: Bool {
        lines.count > previewLineCount
    }

    private var previewText: String {
        lines.prefix(previewLineCount).joined(separator: "\n")
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 2) {
            // Preview/collapsed view
            Button {
                if hasMoreLines {
                    withAnimation(Animations.stateChange) {
                        isExpanded.toggle()
                    }
                    Haptics.selection()
                }
            } label: {
                VStack(alignment: .leading, spacing: 0) {
                    HStack(alignment: .top, spacing: Spacing.xxs) {
                        // Output indicator
                        Text("⎿")
                            .font(Typography.terminal)
                            .foregroundStyle(ColorSystem.textQuaternary)

                        Group {
                            if searchText.isEmpty {
                                Text(isExpanded ? output : previewText)
                            } else {
                                HighlightedText(isExpanded ? output : previewText, highlighting: searchText)
                            }
                        }
                        .font(Typography.terminal)
                        .foregroundStyle(isError ? ColorSystem.error : ColorSystem.Bash.output)
                        .textSelection(.enabled)
                        .fixedSize(horizontal: false, vertical: true)
                        .frame(maxWidth: .infinity, alignment: .leading)
                    }

                    // Expand indicator
                    if hasMoreLines && !isExpanded {
                        HStack(spacing: Spacing.xxs) {
                            Text("…")
                                .font(Typography.terminal)
                                .foregroundStyle(ColorSystem.textQuaternary)

                            Text("+\(lines.count - previewLineCount) lines")
                                .font(Typography.terminalSmall)
                                .foregroundStyle(ColorSystem.textQuaternary)
                        }
                        .padding(.leading, Spacing.sm)
                    }

                    // Collapse indicator
                    if isExpanded && hasMoreLines {
                        Button {
                            withAnimation(Animations.stateChange) {
                                isExpanded = false
                            }
                            Haptics.selection()
                        } label: {
                            Text("collapse")
                                .font(Typography.terminalSmall)
                                .foregroundStyle(ColorSystem.textQuaternary)
                        }
                        .padding(.top, Spacing.xxs)
                        .padding(.leading, Spacing.sm)
                    }
                }
            }
            .buttonStyle(.plain)
        }
        .frame(minHeight: 20)
    }
}

// MARK: - Local Command Output View

/// Displays local command output (like /model command)
private struct LocalCommandOutputView: View {
    let output: String
    var searchText: String = ""

    var body: some View {
        HStack(alignment: .top, spacing: Spacing.xxs) {
            Text("⎿")
                .font(Typography.terminal)
                .foregroundStyle(ColorSystem.textQuaternary)

            if searchText.isEmpty {
                Text(output)
                    .font(Typography.terminal)
                    .foregroundStyle(ColorSystem.textSecondary)
                    .textSelection(.enabled)
                    .fixedSize(horizontal: false, vertical: true)
            } else {
                HighlightedText(output, highlighting: searchText)
                    .font(Typography.terminal)
                    .foregroundStyle(ColorSystem.textSecondary)
                    .textSelection(.enabled)
                    .fixedSize(horizontal: false, vertical: true)
            }

            Spacer(minLength: 0)
        }
        .frame(minHeight: 20)
    }
}

// MARK: - Command Message View

/// Displays slash command from user (like /model)
/// Shows with ">" prefix since it's a user action
private struct CommandMessageView: View {
    let name: String
    let message: String
    var searchText: String = ""

    var body: some View {
        HStack(alignment: .top, spacing: Spacing.xxs) {
            // User prompt indicator
            Text(">")
                .font(Typography.terminal)
                .foregroundStyle(ColorSystem.Log.user)
                .fontWeight(.bold)

            // Command with slash prefix (e.g., "/model")
            Text("/\(message)")
                .font(Typography.terminal)
                .foregroundStyle(ColorSystem.Log.user)
                .textSelection(.enabled)
                .fixedSize(horizontal: false, vertical: true)

            Spacer(minLength: 0)
        }
        .frame(minHeight: 20)
    }
}

// MARK: - Assistant Text View

/// Claude's text response with model badge
/// Parses <thinking> tags and renders markdown
struct AssistantTextElementView: View {
    let content: AssistantTextContent
    var searchText: String = ""

    /// Parsed segments from content (thinking blocks and regular text)
    private var segments: [TextSegment] {
        parseThinkingBlocks(from: content.text)
    }

    var body: some View {
        HStack(alignment: .top, spacing: Spacing.xxs) {
            // Status dot
            Circle()
                .fill(ColorSystem.primary)
                .frame(width: 6, height: 6)
                .padding(.top, 5)

            VStack(alignment: .leading, spacing: 4) {
                // Model badge (if available)
                if let model = content.model {
                    Text(shortModelName(model))
                        .font(Typography.badge)
                        .foregroundStyle(ColorSystem.primary)
                        .padding(.horizontal, 4)
                        .padding(.vertical, 1)
                        .background(ColorSystem.primary.opacity(0.15))
                        .clipShape(Capsule())
                }

                // Render segments (thinking blocks or regular text with markdown)
                ForEach(Array(segments.enumerated()), id: \.offset) { _, segment in
                    switch segment {
                    case .thinking(let text):
                        InlineThinkingView(text: text, searchText: searchText)
                    case .text(let text):
                        if !text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
                            MarkdownTextView(text: text, searchText: searchText)
                        }
                    }
                }
            }

            Spacer(minLength: 0)
        }
        .padding(.vertical, Spacing.xxs)
        .frame(minHeight: 20)
    }

    private func shortModelName(_ model: String) -> String {
        if model.contains("opus") { return "opus" }
        if model.contains("sonnet") { return "sonnet" }
        if model.contains("haiku") { return "haiku" }
        return model.count > 12 ? String(model.prefix(10)) + "..." : model
    }

    /// Parse text for <thinking>...</thinking> blocks
    private func parseThinkingBlocks(from text: String) -> [TextSegment] {
        var segments: [TextSegment] = []
        var remaining = text

        let pattern = #"<thinking>([\s\S]*?)</thinking>"#
        guard let regex = try? NSRegularExpression(pattern: pattern, options: []) else {
            return [.text(text)]
        }

        while let match = regex.firstMatch(in: remaining, options: [], range: NSRange(remaining.startIndex..., in: remaining)) {
            // Text before thinking block
            if let beforeRange = Range(NSRange(location: 0, length: match.range.location), in: remaining) {
                let beforeText = String(remaining[beforeRange])
                if !beforeText.isEmpty {
                    segments.append(.text(beforeText))
                }
            }

            // Thinking content
            if let thinkingRange = Range(match.range(at: 1), in: remaining) {
                let thinkingText = String(remaining[thinkingRange])
                segments.append(.thinking(thinkingText))
            }

            // Move past this match
            if let matchRange = Range(match.range, in: remaining) {
                remaining = String(remaining[matchRange.upperBound...])
            } else {
                break
            }
        }

        // Any remaining text
        if !remaining.isEmpty {
            segments.append(.text(remaining))
        }

        return segments.isEmpty ? [.text(text)] : segments
    }
}

/// Segment type for parsed text
private enum TextSegment {
    case text(String)
    case thinking(String)
}

/// Inline collapsible thinking block (within assistant text)
private struct InlineThinkingView: View {
    let text: String
    var searchText: String = ""
    @State private var isExpanded = false

    var body: some View {
        VStack(alignment: .leading, spacing: 2) {
            // Toggle button
            Button {
                withAnimation(Animations.stateChange) {
                    isExpanded.toggle()
                }
                Haptics.selection()
            } label: {
                HStack(spacing: Spacing.xxs) {
                    Image(systemName: isExpanded ? "chevron.down" : "chevron.right")
                        .font(.system(size: 8, weight: .semibold))
                        .foregroundStyle(ColorSystem.primary.opacity(0.7))

                    // Animated spinner matching Claude Code CLI
                    ThinkingSpinner()

                    Text("Thinking…")
                        .font(Typography.terminalSmall)
                        .italic()
                        .foregroundStyle(ColorSystem.primary.opacity(0.7))
                }
                .padding(.horizontal, 6)
                .padding(.vertical, 3)
                .background(ColorSystem.primary.opacity(0.1))
                .clipShape(RoundedRectangle(cornerRadius: 4))
            }
            .buttonStyle(.plain)

            // Expanded content with search highlighting
            if isExpanded {
                Group {
                    if searchText.isEmpty {
                        Text(text.trimmingCharacters(in: .whitespacesAndNewlines))
                    } else {
                        HighlightedText(text.trimmingCharacters(in: .whitespacesAndNewlines), highlighting: searchText)
                    }
                }
                .font(Typography.terminalSmall)
                .foregroundStyle(ColorSystem.textTertiary)
                .italic()
                .textSelection(.enabled)
                .fixedSize(horizontal: false, vertical: true)
                .padding(.horizontal, Spacing.xs)
                .padding(.vertical, 4)
                .background(ColorSystem.terminalBgHighlight)
                .clipShape(RoundedRectangle(cornerRadius: 4))
                .transition(.opacity.combined(with: .move(edge: .top)))
            }
        }
    }
}

/// Markdown-enabled text view with heading and code block support
private struct MarkdownTextView: View {
    let text: String
    var searchText: String = ""

    /// Parsed blocks (code blocks, headings, text)
    private var parsedBlocks: [MarkdownBlock] {
        var result: [MarkdownBlock] = []
        var currentTextLines: [String] = []
        var insideCodeBlock = false
        var codeBlockLanguage: String = ""
        var codeBlockLines: [String] = []

        for line in text.components(separatedBy: "\n") {
            let trimmed = line.trimmingCharacters(in: .whitespaces)

            // Check for code block fence
            if trimmed.hasPrefix("```") {
                if insideCodeBlock {
                    // Closing fence - emit code block
                    result.append(.codeBlock(language: codeBlockLanguage, code: codeBlockLines.joined(separator: "\n")))
                    codeBlockLines = []
                    codeBlockLanguage = ""
                    insideCodeBlock = false
                } else {
                    // Opening fence - flush any pending text first
                    if !currentTextLines.isEmpty {
                        result.append(.textBlock(lines: currentTextLines))
                        currentTextLines = []
                    }
                    // Extract language hint (e.g., ```swift, ```bash)
                    codeBlockLanguage = String(trimmed.dropFirst(3)).trimmingCharacters(in: .whitespaces)
                    insideCodeBlock = true
                }
            } else if insideCodeBlock {
                codeBlockLines.append(line)
            } else {
                currentTextLines.append(line)
            }
        }

        // Flush remaining content
        if insideCodeBlock && !codeBlockLines.isEmpty {
            // Unclosed code block - treat as code anyway
            result.append(.codeBlock(language: codeBlockLanguage, code: codeBlockLines.joined(separator: "\n")))
        } else if !currentTextLines.isEmpty {
            result.append(.textBlock(lines: currentTextLines))
        }

        return result
    }

    var body: some View {
        VStack(alignment: .leading, spacing: Spacing.xs) {
            ForEach(Array(parsedBlocks.enumerated()), id: \.offset) { _, block in
                switch block {
                case .codeBlock(let language, let code):
                    CodeBlockView(language: language, code: code, searchText: searchText)
                case .textBlock(let lines):
                    textBlockView(lines: lines)
                }
            }
        }
        .fixedSize(horizontal: false, vertical: true)
    }

    @ViewBuilder
    private func textBlockView(lines: [String]) -> some View {
        VStack(alignment: .leading, spacing: 2) {
            ForEach(Array(lines.enumerated()), id: \.offset) { _, line in
                let parsed = parseMarkdownLine(line)
                switch parsed {
                case .heading(let level, let content):
                    headingView(level: level, content: content)
                case .text(let content):
                    if !content.isEmpty {
                        inlineMarkdownText(content)
                    } else {
                        Text(" ")  // Preserve empty lines
                            .font(Typography.terminal)
                    }
                }
            }
        }
        .textSelection(.enabled)
    }

    @ViewBuilder
    private func headingView(level: Int, content: String) -> some View {
        let font: Font = switch level {
        case 1: .system(size: 18, weight: .bold, design: .monospaced)
        case 2: .system(size: 15, weight: .bold, design: .monospaced)
        case 3: .system(size: 13, weight: .semibold, design: .monospaced)
        default: Typography.terminal
        }

        Text(inlineMarkdown(content))
            .font(font)
            .foregroundStyle(ColorSystem.textPrimary)
            .padding(.top, level == 1 ? 4 : 2)
    }

    @ViewBuilder
    private func inlineMarkdownText(_ content: String) -> some View {
        if searchText.isEmpty {
            Text(inlineMarkdown(content))
                .font(Typography.terminal)
                .foregroundStyle(ColorSystem.Log.stdout)
        } else {
            HighlightedText(content, highlighting: searchText)
                .font(Typography.terminal)
                .foregroundStyle(ColorSystem.Log.stdout)
        }
    }

    /// Parse inline markdown (bold, italic, code, links)
    private func inlineMarkdown(_ text: String) -> AttributedString {
        if let attributed = try? AttributedString(markdown: text, options: .init(interpretedSyntax: .inlineOnlyPreservingWhitespace)) {
            return attributed
        }
        return AttributedString(text)
    }

    /// Parse a line to detect headings
    private func parseMarkdownLine(_ line: String) -> MarkdownLine {
        let trimmed = line.trimmingCharacters(in: .whitespaces)

        // Check for heading patterns: # ## ###
        if trimmed.hasPrefix("###") {
            let content = String(trimmed.dropFirst(3)).trimmingCharacters(in: .whitespaces)
            return .heading(level: 3, content: content)
        } else if trimmed.hasPrefix("##") {
            let content = String(trimmed.dropFirst(2)).trimmingCharacters(in: .whitespaces)
            return .heading(level: 2, content: content)
        } else if trimmed.hasPrefix("#") && !trimmed.hasPrefix("#!") {
            // Avoid matching shebang (#!) as heading
            let content = String(trimmed.dropFirst(1)).trimmingCharacters(in: .whitespaces)
            return .heading(level: 1, content: content)
        }

        return .text(line)
    }
}

/// Parsed markdown block types
private enum MarkdownBlock {
    case codeBlock(language: String, code: String)
    case textBlock(lines: [String])
}

/// Parsed markdown line type
private enum MarkdownLine {
    case heading(level: Int, content: String)
    case text(String)
}

// MARK: - Code Block View

/// Styled code block with language label, icon, and copy button
private struct CodeBlockView: View {
    let language: String
    let code: String
    var searchText: String = ""
    @State private var showCopied = false

    /// Language-specific accent color
    private var accentColor: Color {
        switch language.lowercased() {
        case "swift": return Color(hex: "#F05138")  // Swift orange
        case "python", "py": return Color(hex: "#3776AB")  // Python blue
        case "javascript", "js": return Color(hex: "#F7DF1E")  // JS yellow
        case "typescript", "ts": return Color(hex: "#3178C6")  // TS blue
        case "go", "golang": return Color(hex: "#00ADD8")  // Go cyan
        case "rust", "rs": return Color(hex: "#DEA584")  // Rust orange
        case "ruby", "rb": return Color(hex: "#CC342D")  // Ruby red
        case "java": return Color(hex: "#ED8B00")  // Java orange
        case "kotlin", "kt": return Color(hex: "#7F52FF")  // Kotlin purple
        case "bash", "sh", "shell", "zsh": return Color(hex: "#4EAA25")  // Bash green
        case "json": return Color(hex: "#CBCB41")  // JSON yellow
        case "yaml", "yml": return Color(hex: "#CB171E")  // YAML red
        case "html": return Color(hex: "#E34F26")  // HTML orange
        case "css": return Color(hex: "#1572B6")  // CSS blue
        case "sql": return Color(hex: "#CC2927")  // SQL red
        case "c": return Color(hex: "#A8B9CC")  // C gray-blue
        case "cpp", "c++": return Color(hex: "#00599C")  // C++ blue
        case "csharp", "c#", "cs": return Color(hex: "#512BD4")  // C# purple
        case "php": return Color(hex: "#777BB4")  // PHP purple
        case "dart": return Color(hex: "#0175C2")  // Dart blue
        case "markdown", "md": return Color(hex: "#083FA1")  // Markdown blue
        default: return ColorSystem.textTertiary
        }
    }

    /// Language icon (SF Symbol or text fallback)
    private var languageIcon: String {
        switch language.lowercased() {
        case "swift": return "swift"
        case "python", "py": return "sparkles"  // No Python icon, use sparkles
        case "javascript", "js", "typescript", "ts": return "curlybraces"
        case "go", "golang": return "chevron.left.forwardslash.chevron.right"
        case "bash", "sh", "shell", "zsh": return "terminal"
        case "json", "yaml", "yml": return "doc.text"
        case "html", "css": return "globe"
        case "sql": return "cylinder"
        case "markdown", "md": return "text.justify"
        default: return "doc.plaintext"
        }
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Header with language icon, name, and copy button
            HStack(spacing: 6) {
                // Language icon and name
                if !language.isEmpty {
                    HStack(spacing: 4) {
                        Image(systemName: languageIcon)
                            .font(.system(size: 10, weight: .medium))
                        Text(language)
                            .font(Typography.badge)
                    }
                    .foregroundStyle(accentColor)
                } else {
                    Text("code")
                        .font(Typography.badge)
                        .foregroundStyle(ColorSystem.textTertiary)
                }

                Spacer()

                // Copy button
                Button {
                    UIPasteboard.general.string = code
                    Haptics.light()
                    withAnimation {
                        showCopied = true
                    }
                    DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                        withAnimation {
                            showCopied = false
                        }
                    }
                } label: {
                    HStack(spacing: 4) {
                        Image(systemName: showCopied ? "checkmark" : "doc.on.doc")
                            .font(.system(size: 10))
                        Text(showCopied ? "Copied" : "Copy")
                            .font(Typography.badge)
                    }
                    .foregroundStyle(showCopied ? ColorSystem.success : ColorSystem.textTertiary)
                    .padding(.horizontal, 6)
                    .padding(.vertical, 3)
                    .background(ColorSystem.terminalBg.opacity(0.5))
                    .clipShape(RoundedRectangle(cornerRadius: 4))
                }
                .buttonStyle(.plain)
            }
            .padding(.horizontal, Spacing.sm)
            .padding(.vertical, Spacing.xs)
            .background(ColorSystem.terminalBg.opacity(0.8))

            // Code content with horizontal scroll and search highlighting
            ScrollView(.horizontal, showsIndicators: false) {
                Group {
                    if searchText.isEmpty {
                        Text(code)
                    } else {
                        HighlightedText(code, highlighting: searchText)
                    }
                }
                .font(Typography.terminal)
                .foregroundStyle(ColorSystem.textPrimary)
                .textSelection(.enabled)
                .fixedSize(horizontal: true, vertical: true)
                .padding(Spacing.sm)
            }
        }
        .background(ColorSystem.terminalBgHighlight)
        .clipShape(RoundedRectangle(cornerRadius: CornerRadius.small))
        .overlay(
            RoundedRectangle(cornerRadius: CornerRadius.small)
                .stroke(accentColor.opacity(0.3), lineWidth: 1)
        )
    }
}

// MARK: - Tool Call View

/// Tool invocation display with status indicator
struct ToolCallElementView: View {
    let content: ToolCallContent
    var searchText: String = ""

    var body: some View {
        HStack(alignment: .top, spacing: Spacing.xxs) {
            // Status indicator
            statusIndicator
                .padding(.top, 5)

            // Tool name and params combined (no spaces around parentheses)
            Group {
                if searchText.isEmpty {
                    Text(toolDisplay)
                } else {
                    HighlightedText(toolDisplay, highlighting: searchText)
                }
            }
            .font(Typography.terminal)
            .foregroundStyle(ColorSystem.Tool.name)
            .lineLimit(2)
            .fixedSize(horizontal: false, vertical: true)

            Spacer(minLength: 0)

            // Running spinner
            if content.status == .running {
                ProgressView()
                    .scaleEffect(0.6)
                    .tint(ColorSystem.primary)
            }
        }
        .padding(.vertical, Spacing.xxs)
        .frame(minHeight: 20)
    }

    @ViewBuilder
    private var statusIndicator: some View {
        switch content.status {
        case .running:
            Circle()
                .fill(ColorSystem.info)
                .frame(width: 6, height: 6)
        case .completed:
            Circle()
                .fill(ColorSystem.primary)
                .frame(width: 6, height: 6)
        case .error:
            Circle()
                .fill(ColorSystem.error)
                .frame(width: 6, height: 6)
        case .interrupted:
            Circle()
                .fill(ColorSystem.warning)
                .frame(width: 6, height: 6)
        }
    }

    private var toolDisplay: String {
        let params = displayParams
        if params.isEmpty {
            return content.tool
        }
        return "\(content.tool)(\(params))"
    }

    private var displayParams: String {
        // Priority: command > file_path > pattern > args
        if let cmd = content.params["command"] {
            return cmd
        }
        if let path = content.params["file_path"] {
            return path
        }
        if let pattern = content.params["pattern"] {
            return "pattern: \"\(pattern)\""
        }
        if let args = content.params["args"] {
            return args
        }
        if !content.display.isEmpty {
            return content.display
        }
        return ""
    }
}

// MARK: - Tool Result View

/// Collapsible tool result with error state
/// Specialized rendering for WebSearch results
struct ToolResultElementView: View {
    let content: ToolResultContent
    var searchText: String = ""
    @State private var isExpanded = false

    private let previewLineCount = 3

    /// Content with system-reminder tags stripped (internal Claude Code messages)
    private var displayContent: String {
        stripSystemTags(from: content.fullContent)
    }

    /// Strip internal system tags that shouldn't be displayed to users
    private func stripSystemTags(from text: String) -> String {
        var result = text
        // Remove <system-reminder>...</system-reminder> tags
        result = result.replacingOccurrences(
            of: #"<system-reminder>[\s\S]*?</system-reminder>"#,
            with: "",
            options: .regularExpression
        )
        return result.trimmingCharacters(in: .whitespacesAndNewlines)
    }

    /// Parsed web search result (if this is a WebSearch tool result)
    private var webSearchResult: ParsedWebSearchResult? {
        // Check if this is a WebSearch result by content pattern
        guard displayContent.contains("Web search results for query:"),
              displayContent.contains("Links: [") else {
            return nil
        }
        return WebSearchParser.parse(displayContent)
    }

    var body: some View {
        // Use specialized view for WebSearch results
        if let webSearch = webSearchResult, webSearch.isValid {
            WebSearchResultView(result: webSearch, searchText: searchText)
        } else {
            // Standard tool result display
            standardResultView
        }
    }

    // MARK: - Standard Result View

    private var standardResultView: some View {
        VStack(alignment: .leading, spacing: 2) {
            // Summary/Preview row (always visible)
            Button {
                if hasMoreLines {
                    withAnimation(Animations.stateChange) {
                        isExpanded.toggle()
                    }
                    Haptics.selection()
                }
            } label: {
                VStack(alignment: .leading, spacing: 0) {
                    // Preview lines with indicator
                    HStack(alignment: .top, spacing: Spacing.xxs) {
                        Text("⎿")
                            .font(Typography.terminal)
                            .foregroundStyle(ColorSystem.textQuaternary)

                        Group {
                            if searchText.isEmpty {
                                Text(previewText.isEmpty ? "(No content)" : previewText)
                            } else {
                                HighlightedText(previewText.isEmpty ? "(empty)" : previewText, highlighting: searchText)
                            }
                        }
                        .font(Typography.terminal)
                        .foregroundStyle(content.isError ? ColorSystem.error : ColorSystem.textSecondary)
                        .textSelection(.enabled)
                        .fixedSize(horizontal: false, vertical: true)
                        .frame(maxWidth: .infinity, alignment: .leading)
                    }
                    .frame(minHeight: 20)

                    // Expand indicator (if more lines available)
                    if hasMoreLines && !isExpanded {
                        HStack(spacing: Spacing.xxs) {
                            Text("…")
                                .font(Typography.terminal)
                                .foregroundStyle(ColorSystem.textQuaternary)

                            Text("+\(displayLineCount - previewLineCount) lines (tap to expand)")
                                .font(Typography.terminalSmall)
                                .foregroundStyle(ColorSystem.textQuaternary)
                        }
                        .padding(.leading, Spacing.sm)
                    }
                }
            }
            .buttonStyle(.plain)

            // Expanded content
            if isExpanded {
                VStack(alignment: .leading, spacing: 0) {
                    Group {
                        if searchText.isEmpty {
                            Text(displayContent)
                        } else {
                            HighlightedText(displayContent, highlighting: searchText)
                        }
                    }
                    .font(Typography.terminalSmall)
                    .foregroundStyle(content.isError ? ColorSystem.error : ColorSystem.textTertiary)
                    .textSelection(.enabled)
                    .frame(maxWidth: .infinity, alignment: .leading)

                    // Collapse button
                    Button {
                        withAnimation(Animations.stateChange) {
                            isExpanded = false
                        }
                        Haptics.selection()
                    } label: {
                        Text("collapse")
                            .font(Typography.terminalSmall)
                            .foregroundStyle(ColorSystem.textQuaternary)
                    }
                    .padding(.top, Spacing.xxs)
                }
                .padding(.leading, Spacing.md)
                .padding(.vertical, Spacing.xxs)
                .background(ColorSystem.terminalBgHighlight)
                .clipShape(RoundedRectangle(cornerRadius: 4))
                .transition(.opacity.combined(with: .move(edge: .top)))
            }
        }
        .padding(.vertical, Spacing.xxs)
        .frame(minHeight: 20)
    }

    /// Line count for display content (after filtering system tags)
    private var displayLineCount: Int {
        displayContent.components(separatedBy: "\n").count
    }

    private var hasMoreLines: Bool {
        displayLineCount > previewLineCount
    }

    private var previewText: String {
        guard !displayContent.isEmpty else { return "" }
        let lines = displayContent.components(separatedBy: "\n")
        return lines.prefix(previewLineCount).joined(separator: "\n")
    }
}

// MARK: - Diff View

/// File diff display with syntax highlighting
struct DiffElementView: View {
    let content: DiffContent
    @State private var isExpanded = true

    var body: some View {
        VStack(alignment: .leading, spacing: 2) {
            // Header
            Button {
                withAnimation(Animations.stateChange) {
                    isExpanded.toggle()
                }
                Haptics.selection()
            } label: {
                HStack(spacing: Spacing.xxs) {
                    Image(systemName: isExpanded ? "chevron.down" : "chevron.right")
                        .font(.system(size: 8, weight: .semibold))
                        .foregroundStyle(ColorSystem.textQuaternary)

                    Text("└")
                        .font(Typography.terminal)
                        .foregroundStyle(ColorSystem.textQuaternary)

                    // Summary with +/- counts
                    HStack(spacing: 4) {
                        Text("+\(content.summary.added)")
                            .foregroundStyle(ColorSystem.Diff.added)
                        Text("-\(content.summary.removed)")
                            .foregroundStyle(ColorSystem.Diff.removed)
                    }
                    .font(Typography.terminalSmall)

                    // File path
                    Text(shortenPath(content.filePath))
                        .font(Typography.terminalSmall)
                        .foregroundStyle(ColorSystem.textTertiary)
                        .lineLimit(1)
                        .truncationMode(.middle)

                    Spacer()
                }
            }
            .buttonStyle(.plain)

            // Diff lines
            if isExpanded {
                VStack(alignment: .leading, spacing: 0) {
                    ForEach(content.hunks) { hunk in
                        ForEach(hunk.lines) { line in
                            DiffLineElementView(line: line)
                        }
                    }
                }
                .padding(.leading, Spacing.md)
                .transition(.opacity.combined(with: .move(edge: .top)))
            }
        }
        .padding(.vertical, Spacing.xxs)
        .frame(minHeight: 20)
    }

    private func shortenPath(_ path: String) -> String {
        // Show last 2 components
        let components = path.components(separatedBy: "/")
        if components.count > 2 {
            return ".../" + components.suffix(2).joined(separator: "/")
        }
        return path
    }
}

/// Individual diff line with proper coloring
struct DiffLineElementView: View {
    let line: ElementDiffLine

    var body: some View {
        HStack(spacing: 0) {
            // Line number
            Text(lineNumber)
                .font(Typography.terminalSmall)
                .foregroundStyle(ColorSystem.textQuaternary)
                .frame(width: 28, alignment: .trailing)

            // Change prefix
            Text(prefix)
                .font(Typography.terminalSmall)
                .foregroundStyle(prefixColor)
                .frame(width: 14)

            // Content
            Text(line.content)
                .font(Typography.terminalSmall)
                .foregroundStyle(contentColor)
                .lineLimit(1)

            Spacer(minLength: 0)
        }
        .frame(minHeight: 14)
        .background(backgroundColor)
    }

    private var lineNumber: String {
        if let num = line.newLine ?? line.oldLine {
            return String(num)
        }
        return ""
    }

    private var prefix: String {
        switch line.type {
        case .added: return "+"
        case .removed: return "-"
        case .context: return " "
        }
    }

    private var prefixColor: Color {
        switch line.type {
        case .added: return ColorSystem.Diff.added
        case .removed: return ColorSystem.Diff.removed
        case .context: return ColorSystem.textQuaternary
        }
    }

    private var contentColor: Color {
        switch line.type {
        case .added: return ColorSystem.Diff.added
        case .removed: return ColorSystem.Diff.removed
        case .context: return ColorSystem.textTertiary
        }
    }

    private var backgroundColor: Color {
        switch line.type {
        case .added: return ColorSystem.Diff.addedBg
        case .removed: return ColorSystem.Diff.removedBg
        case .context: return .clear
        }
    }
}

// MARK: - Edit Diff View (Claude Code CLI Style)

/// Edit tool diff display with Update(file) header and line-by-line comparison
/// Styled like Claude Code CLI with collapsible diff content
struct EditDiffElementView: View {
    let content: EditDiffContent
    var searchText: String = ""
    @State private var isExpanded = true

    /// How many context lines to show around changes
    private let contextRadius = 3

    /// Filtered lines showing only changes with surrounding context
    private var filteredLines: [EditDiffLine] {
        // If small diff, show all
        if content.lines.count <= 20 {
            return content.lines
        }

        // For larger diffs, show changes with context
        var result: [EditDiffLine] = []
        var includeIndices = Set<Int>()

        // Mark indices around changes
        for (i, line) in content.lines.enumerated() {
            if line.type != .context {
                for j in max(0, i - contextRadius)...min(content.lines.count - 1, i + contextRadius) {
                    includeIndices.insert(j)
                }
            }
        }

        // Build filtered list with ellipsis markers
        var lastIncluded = -1
        var ellipsisCount = 0
        for i in 0..<content.lines.count {
            if includeIndices.contains(i) {
                // Add ellipsis if there's a gap (with unique ID to avoid ForEach duplicates)
                if lastIncluded >= 0 && i - lastIncluded > 1 {
                    ellipsisCount += 1
                    result.append(EditDiffLine(
                        type: .context,
                        oldLine: nil,
                        newLine: nil,
                        content: "...",
                        uniqueId: "ellipsis-\(ellipsisCount)"
                    ))
                }
                result.append(content.lines[i])
                lastIncluded = i
            }
        }

        return result
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 2) {
            // Header: ● Update(file) + Added X lines, removed Y lines
            Button {
                withAnimation(Animations.stateChange) {
                    isExpanded.toggle()
                }
                Haptics.selection()
            } label: {
                headerView
            }
            .buttonStyle(.plain)

            // Diff lines (collapsible) with horizontal scroll for long lines
            if isExpanded {
                ScrollView(.horizontal, showsIndicators: false) {
                    VStack(alignment: .leading, spacing: 0) {
                        ForEach(filteredLines) { line in
                            EditDiffLineView(line: line, searchText: searchText)
                        }
                    }
                    .padding(.leading, Spacing.sm)
                }
                .background(ColorSystem.terminalBgHighlight.opacity(0.3))
                .clipShape(RoundedRectangle(cornerRadius: CornerRadius.small))
                .transition(.opacity.combined(with: .move(edge: .top)))
            }
        }
        .padding(.vertical, Spacing.xxs)
        .frame(minHeight: 20)
    }

    private var headerView: some View {
        VStack(alignment: .leading, spacing: 2) {
            // First line: Update(file_path)
            HStack(spacing: Spacing.xxs) {
                // Status indicator
                Circle()
                    .fill(statusColor)
                    .frame(width: 6, height: 6)

                // Expand/collapse chevron
                Image(systemName: isExpanded ? "chevron.down" : "chevron.right")
                    .font(.system(size: 8, weight: .semibold))
                    .foregroundStyle(ColorSystem.textQuaternary)

                // Update(file_path)
                Text("Update")
                    .font(Typography.terminal)
                    .foregroundStyle(ColorSystem.Tool.name)

                Text("(\(shortenPath(content.filePath)))")
                    .font(Typography.terminal)
                    .foregroundStyle(ColorSystem.textSecondary)
                    .lineLimit(1)
                    .truncationMode(.middle)

                Spacer()
            }

            // Second line: ⎿  Added X lines, removed Y lines
            HStack(spacing: Spacing.xxs) {
                Text("⎿")
                    .font(Typography.terminal)
                    .foregroundStyle(ColorSystem.textQuaternary)

                summaryBadge
            }
            .padding(.leading, Spacing.sm)
        }
    }

    private var summaryBadge: some View {
        HStack(spacing: 2) {
            if content.addedLines > 0 {
                Text("Added \(content.addedLines) line\(content.addedLines == 1 ? "" : "s")")
                    .font(Typography.terminalSmall)
                    .foregroundStyle(ColorSystem.Diff.added)
            }
            if content.removedLines > 0 {
                Text(content.addedLines > 0 ? ", removed \(content.removedLines) line\(content.removedLines == 1 ? "" : "s")" : "Removed \(content.removedLines) line\(content.removedLines == 1 ? "" : "s")")
                    .font(Typography.terminalSmall)
                    .foregroundStyle(ColorSystem.Diff.removed)
            }
        }
    }

    private var statusColor: Color {
        switch content.status {
        case .running: return ColorSystem.info
        case .completed: return ColorSystem.primary
        case .error: return ColorSystem.error
        case .interrupted: return ColorSystem.warning
        }
    }

    private func shortenPath(_ path: String) -> String {
        let components = path.components(separatedBy: "/")
        if components.count > 2 {
            return ".../" + components.suffix(2).joined(separator: "/")
        }
        return path
    }
}

/// Individual line in Edit diff display
private struct EditDiffLineView: View {
    let line: EditDiffLine
    var searchText: String = ""

    var body: some View {
        HStack(spacing: 0) {
            // Line number
            Text(lineNumber)
                .font(Typography.terminalSmall)
                .foregroundStyle(ColorSystem.textQuaternary)
                .frame(width: 32, alignment: .trailing)

            // Change prefix (+, -, or space)
            Text(prefix)
                .font(Typography.terminalSmall)
                .foregroundStyle(prefixColor)
                .frame(width: 14)

            // Content with search highlighting (no truncation for horizontal scroll)
            Group {
                if searchText.isEmpty {
                    Text(line.content)
                } else {
                    HighlightedText(line.content, highlighting: searchText)
                }
            }
            .font(Typography.terminalSmall)
            .foregroundStyle(contentColor)
            .lineLimit(1)
            .fixedSize(horizontal: true, vertical: false)
            .textSelection(.enabled)
        }
        .frame(minHeight: 16)
        .background(backgroundColor)
    }

    private var lineNumber: String {
        if line.content == "..." {
            return ""
        }
        if let num = line.newLine ?? line.oldLine {
            return String(num)
        }
        return ""
    }

    private var prefix: String {
        if line.content == "..." {
            return " "
        }
        switch line.type {
        case .added: return "+"
        case .removed: return "-"
        case .context: return " "
        }
    }

    private var prefixColor: Color {
        switch line.type {
        case .added: return ColorSystem.Diff.added
        case .removed: return ColorSystem.Diff.removed
        case .context: return ColorSystem.textQuaternary
        }
    }

    private var contentColor: Color {
        switch line.type {
        case .added: return ColorSystem.Diff.added
        case .removed: return ColorSystem.Diff.removed
        case .context: return ColorSystem.textTertiary
        }
    }

    private var backgroundColor: Color {
        switch line.type {
        case .added: return ColorSystem.Diff.addedBg
        case .removed: return ColorSystem.Diff.removedBg
        case .context: return .clear
        }
    }
}

// MARK: - Thinking Spinner

/// Animated spinner matching Claude Code CLI style
/// Cycles through frames: · → ✢ → ✳ → ✶ → ✻ → ✽ (forward then reverse)
struct ThinkingSpinner: View {
    /// Spinner frames (macOS style from Claude Code CLI)
//    private static let baseFrames = ["·", "✢", "✳", "✶", "✻", "✽"]
    private static let baseFrames = ["·", "✢", "⏺", "✶", "✻", "✽"]

    /// Full animation sequence: forward + reverse for smooth loop
    private static let animationFrames: [String] = {
        baseFrames + baseFrames.reversed()
    }()

    /// Animation interval (200ms for thinking state)
    private let interval: TimeInterval = 0.2

    @State private var frameIndex = 0
    @State private var timer: Timer?

    var body: some View {
        Text(Self.animationFrames[frameIndex % Self.animationFrames.count])
            .font(.system(size: 12, weight: .medium))
            .foregroundStyle(ColorSystem.primary.opacity(0.8))
            .onAppear {
                startAnimation()
            }
            .onDisappear {
                stopAnimation()
            }
    }

    private func startAnimation() {
        // Start with random frame for variety
        frameIndex = Int.random(in: 0..<Self.animationFrames.count)

        timer = Timer.scheduledTimer(withTimeInterval: interval, repeats: true) { _ in
            frameIndex = (frameIndex + 1) % Self.animationFrames.count
        }
    }

    private func stopAnimation() {
        timer?.invalidate()
        timer = nil
    }
}

// MARK: - Thinking View

/// Collapsible thinking/reasoning block
struct ThinkingElementView: View {
    let content: ThinkingContent
    var searchText: String = ""
    @State private var isExpanded = false

    var body: some View {
        // Don't render if thinking content is empty or whitespace only
        if content.text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            EmptyView()
        } else {
            thinkingContent
        }
    }

    @ViewBuilder
    private var thinkingContent: some View {
        VStack(alignment: .leading, spacing: 2) {
            // Toggle button
            Button {
                withAnimation(Animations.stateChange) {
                    isExpanded.toggle()
                }
                Haptics.selection()
            } label: {
                HStack(spacing: Spacing.xxs) {
                    Image(systemName: isExpanded ? "chevron.down" : "chevron.right")
                        .font(.system(size: 8, weight: .semibold))
                        .foregroundStyle(ColorSystem.primary.opacity(0.7))

                    // Animated spinner matching Claude Code CLI
                    ThinkingSpinner()

                    Text("Thinking…")
                        .font(Typography.terminalSmall)
                        .italic()
                        .foregroundStyle(ColorSystem.primary.opacity(0.7))
                }
                .padding(.horizontal, 6)
                .padding(.vertical, 3)
                .background(ColorSystem.primary.opacity(0.1))
                .clipShape(RoundedRectangle(cornerRadius: 4))
            }
            .buttonStyle(.plain)

            // Expanded content with search highlighting
            if isExpanded {
                Group {
                    if searchText.isEmpty {
                        Text(content.text)
                    } else {
                        HighlightedText(content.text, highlighting: searchText)
                    }
                }
                .font(Typography.terminalSmall)
                .foregroundStyle(ColorSystem.textTertiary)
                .italic()
                .textSelection(.enabled)
                .fixedSize(horizontal: false, vertical: true)
                .padding(.horizontal, Spacing.xs)
                .padding(.vertical, 4)
                .background(ColorSystem.terminalBgHighlight)
                .clipShape(RoundedRectangle(cornerRadius: 4))
                .padding(.leading, Spacing.sm)
                .transition(.opacity.combined(with: .move(edge: .top)))
            }
        }
        .padding(.vertical, Spacing.xxs)
        .frame(minHeight: 20)
    }
}

// MARK: - Interrupted View

/// User interruption display
struct InterruptedElementView: View {
    let content: InterruptedContent

    var body: some View {
        HStack(spacing: Spacing.xxs) {
            Text("⎿")
                .font(Typography.terminal)
                .foregroundStyle(ColorSystem.textQuaternary)

            Text("Interrupted")
                .font(Typography.terminal)
                .foregroundStyle(ColorSystem.warning)
                .fontWeight(.medium)

            Text("·")
                .foregroundStyle(ColorSystem.textQuaternary)

            Text(content.message)
                .font(Typography.terminal)
                .foregroundStyle(ColorSystem.textTertiary)
                .fixedSize(horizontal: false, vertical: true)

            Spacer(minLength: 0)
        }
        .padding(.vertical, Spacing.xxs)
        .frame(minHeight: 20)
    }
}

// MARK: - Context Compaction View

/// Context compaction indicator - shown when Claude Code compacts conversation
/// Styled like Claude Code's "Conversation compacted" divider
struct ContextCompactionElementView: View {
    let content: ContextCompactionContent
    @State private var isExpanded = false

    var body: some View {
        VStack(alignment: .leading, spacing: Spacing.xs) {
            // Divider with label (Claude Code style)
            Button {
                withAnimation(Animations.stateChange) {
                    isExpanded.toggle()
                }
                Haptics.selection()
            } label: {
                HStack(spacing: Spacing.sm) {
                    // Left line
                    Rectangle()
                        .fill(ColorSystem.textQuaternary.opacity(0.3))
                        .frame(height: 1)
                        .frame(maxWidth: 40)

                    // Label - fixed size to prevent wrapping
                    HStack(spacing: Spacing.xxs) {
                        Image(systemName: isExpanded ? "chevron.down" : "chevron.right")
                            .font(.system(size: 8, weight: .semibold))

                        Text("Conversation compacted")
                            .font(Typography.terminalSmall)
                            .lineLimit(1)
                    }
                    .foregroundStyle(ColorSystem.textTertiary)
                    .fixedSize(horizontal: true, vertical: false)

                    // Right line
                    Rectangle()
                        .fill(ColorSystem.textQuaternary.opacity(0.3))
                        .frame(height: 1)
                }
            }
            .buttonStyle(.plain)

            // Expanded summary (collapsible)
            if isExpanded {
                VStack(alignment: .leading, spacing: Spacing.xxs) {
                    Text("Summary")
                        .font(Typography.badge)
                        .foregroundStyle(ColorSystem.textTertiary)

                    Text(content.summary)
                        .font(Typography.terminalSmall)
                        .foregroundStyle(ColorSystem.textSecondary)
                        .textSelection(.enabled)
                        .fixedSize(horizontal: false, vertical: true)
                        .lineLimit(20)  // Limit to prevent huge expansion
                }
                .padding(Spacing.sm)
                .background(ColorSystem.terminalBgHighlight)
                .clipShape(RoundedRectangle(cornerRadius: CornerRadius.small))
                .transition(.opacity.combined(with: .move(edge: .top)))
            }
        }
        .padding(.vertical, Spacing.sm)
        .frame(maxWidth: .infinity)
    }
}

// MARK: - Elements List View

/// Scrollable list of chat elements
struct ElementsListView: View {
    let elements: [ChatElement]
    let showTimestamps: Bool
    @Binding var isAutoScrollEnabled: Bool

    @State private var scrollProxy: ScrollViewProxy?
    @State private var scrollTask: Task<Void, Never>?
    @State private var lastScrolledCount = 0

    init(elements: [ChatElement], showTimestamps: Bool = false, isAutoScrollEnabled: Binding<Bool> = .constant(true)) {
        self.elements = elements
        self.showTimestamps = showTimestamps
        self._isAutoScrollEnabled = isAutoScrollEnabled
    }

    var body: some View {
        ScrollViewReader { proxy in
            ScrollView {
                LazyVStack(alignment: .leading, spacing: 0) {
                    ForEach(elements) { element in
                        ElementView(element: element, showTimestamp: showTimestamps)
                            .id(element.id)
                    }

                    // Bottom anchor
                    Color.clear
                        .frame(height: 1)
                        .id("bottom")
                }
                .padding(.horizontal, Spacing.xs)
                .padding(.vertical, Spacing.xs)
            }
            .onAppear {
                scrollProxy = proxy
                scheduleScrollToBottom()
            }
            .onChange(of: elements.count) { oldCount, newCount in
                guard isAutoScrollEnabled, newCount > oldCount, newCount != lastScrolledCount else { return }
                scheduleScrollToBottom()
            }
        }
        .background(ColorSystem.terminalBg)
    }

    /// Debounced scroll to prevent multiple updates per frame
    private func scheduleScrollToBottom() {
        guard !elements.isEmpty else { return }

        scrollTask?.cancel()
        scrollTask = Task { @MainActor in
            try? await Task.sleep(nanoseconds: 50_000_000) // 50ms debounce
            guard !Task.isCancelled else { return }

            lastScrolledCount = elements.count
            withAnimation(Animations.logAppear) {
                scrollProxy?.scrollTo("bottom", anchor: .bottom)
            }
        }
    }
}
// MARK: - Task Group View

/// Task group display - collapsible group of related tasks
/// Matches Claude Code CLI format: "3 Explore agents finished (ctrl+o to expand)"
struct TaskGroupElementView: View {
    @Environment(\.horizontalSizeClass) private var sizeClass
    @State private var isExpanded: Bool
    let content: TaskGroupContent
    var searchText: String = ""

    private var layout: ResponsiveLayout {
        ResponsiveLayout.current(for: sizeClass)
    }

    init(content: TaskGroupContent, searchText: String = "") {
        self.content = content
        self.searchText = searchText
        self._isExpanded = State(initialValue: content.isExpanded)
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 0) {
            // Header with count and status
            headerView

            // Expanded task list
            if isExpanded {
                ForEach(content.tasks) { task in
                    TaskRowView(task: task, searchText: searchText)
                        .padding(.leading, 16)  // Tree indentation
                }
            }
        }
        .padding(.vertical, Spacing.xxs)
    }

    private var headerView: some View {
        Button {
            withAnimation(.easeOut(duration: 0.2)) {
                isExpanded.toggle()
            }
            Haptics.light()
        } label: {
            HStack(spacing: 6) {
                // Expansion chevron
                Image(systemName: isExpanded ? "chevron.down" : "chevron.right")
                    .font(.system(size: layout.iconSmall, weight: .semibold))
                    .foregroundStyle(ColorSystem.textTertiary)
                    .frame(width: 12)

                // Count and status
                HStack(spacing: 4) {
                    // Status dot
                    Circle()
                        .fill(headerColor)
                        .frame(width: 6, height: 6)

                    // Count and type
                    Text("\(content.count) \(content.agentType) agent\(content.count == 1 ? "" : "s") \(statusText)")
                        .font(Typography.terminal)
                        .foregroundStyle(ColorSystem.textPrimary)

                    if !isExpanded {
                        Text("(tap to expand)")
                            .font(Typography.terminalSmall)
                            .foregroundStyle(ColorSystem.textQuaternary)
                    }
                }
            }
            .padding(.vertical, 4)
            .contentShape(Rectangle())
        }
        .buttonStyle(.plain)
    }

    private var statusText: String {
        if content.anyFailed {
            return "failed"
        } else if content.allCompleted {
            return "finished"
        } else {
            return "running"
        }
    }

    private var headerColor: Color {
        if content.anyFailed {
            return ColorSystem.error
        } else if content.allCompleted {
            return ColorSystem.success
        } else {
            return ColorSystem.primary
        }
    }
}

// MARK: - Task Row View

/// Individual task row in task group
/// Shows: description · tool uses · tokens, with status indicator
struct TaskRowView: View {
    @Environment(\.horizontalSizeClass) private var sizeClass
    let task: TaskContent
    var searchText: String = ""

    private var layout: ResponsiveLayout {
        ResponsiveLayout.current(for: sizeClass)
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 2) {
            // Main task line: description and metadata
            HStack(spacing: 4) {
                // Tree connector
                Text("├─")
                    .font(.system(size: 10, design: .monospaced))
                    .foregroundStyle(ColorSystem.textQuaternary)

                // Status indicator
                statusIndicator

                // Description
                if searchText.isEmpty {
                    Text(task.description)
                        .font(Typography.terminal)
                        .foregroundStyle(ColorSystem.textPrimary)
                        .fixedSize(horizontal: false, vertical: true)
                } else {
                    HighlightedText(task.description, highlighting: searchText)
                        .font(Typography.terminal)
                        .foregroundStyle(ColorSystem.textPrimary)
                }

                // Metadata
                metadataView
            }

            // Status line: "Done" or "Running"
            if task.status != .running {
                HStack(spacing: 4) {
                    Text("│  └")
                        .font(.system(size: 10, design: .monospaced))
                        .foregroundStyle(ColorSystem.textQuaternary)

                    Text(statusText)
                        .font(Typography.terminalSmall)
                        .foregroundStyle(statusColor)
                }
                .padding(.leading, 8)
            }
        }
        .padding(.vertical, 2)
    }

    @ViewBuilder
    private var statusIndicator: some View {
        switch task.status {
        case .running:
            ProgressView()
                .controlSize(.mini)
                .scaleEffect(0.7)
                .frame(width: 12, height: 12)
        case .completed:
            Image(systemName: "checkmark.circle.fill")
                .font(.system(size: 10))
                .foregroundStyle(ColorSystem.success)
        case .failed:
            Image(systemName: "xmark.circle.fill")
                .font(.system(size: 10))
                .foregroundStyle(ColorSystem.error)
        }
    }

    @ViewBuilder
    private var metadataView: some View {
        HStack(spacing: 4) {
            // Tool uses
            if let toolUses = task.toolUses {
                Group {
                    Text("·")
                    Text("\(toolUses) tool use\(toolUses == 1 ? "" : "s")")
                }
                .font(Typography.terminalSmall)
                .foregroundStyle(ColorSystem.textTertiary)
            }

            // Tokens
            if let outputTokens = task.outputTokens {
                Group {
                    Text("·")
                    Text(formatTokens(outputTokens))
                }
                .font(Typography.terminalSmall)
                .foregroundStyle(ColorSystem.textTertiary)
            }
        }
    }

    private var statusText: String {
        switch task.status {
        case .running: return "Running"
        case .completed: return "Done"
        case .failed: return "Failed"
        }
    }

    private var statusColor: Color {
        switch task.status {
        case .running: return ColorSystem.primary
        case .completed: return ColorSystem.success
        case .failed: return ColorSystem.error
        }
    }

    private func formatTokens(_ tokens: Int) -> String {
        if tokens >= 1000 {
            return String(format: "%.1fk tokens", Double(tokens) / 1000)
        }
        return "\(tokens) tokens"
    }
}

// MARK: - Individual Task Element View

/// Standalone task element (not in a group)
/// Displays same format as task rows but without grouping
struct TaskElementView: View {
    let content: TaskContent
    var searchText: String = ""

    var body: some View {
        VStack(alignment: .leading, spacing: 2) {
            HStack(spacing: 6) {
                // Status indicator
                statusIndicator

                // Task type badge
                Text(content.agentType.uppercased())
                    .font(.system(size: 8, weight: .bold, design: .monospaced))
                    .foregroundStyle(ColorSystem.primary)
                    .padding(.horizontal, 4)
                    .padding(.vertical, 1)
                    .background(ColorSystem.primary.opacity(0.15))
                    .clipShape(RoundedRectangle(cornerRadius: 3))

                // Description
                if searchText.isEmpty {
                    Text(content.description)
                        .font(Typography.terminal)
                        .foregroundStyle(ColorSystem.textPrimary)
                        .fixedSize(horizontal: false, vertical: true)
                } else {
                    HighlightedText(content.description, highlighting: searchText)
                        .font(Typography.terminal)
                        .foregroundStyle(ColorSystem.textPrimary)
                }

                Spacer()

                // Metadata
                metadataView
            }

            // Status text
            if content.status != .running {
                HStack(spacing: 4) {
                    Text("└")
                        .font(.system(size: 10, design: .monospaced))
                        .foregroundStyle(ColorSystem.textQuaternary)

                    Text(statusText)
                        .font(Typography.terminalSmall)
                        .foregroundStyle(statusColor)
                }
                .padding(.leading, 20)
            }
        }
        .padding(.vertical, Spacing.xxs)
    }

    @ViewBuilder
    private var statusIndicator: some View {
        switch content.status {
        case .running:
            ProgressView()
                .controlSize(.mini)
                .scaleEffect(0.8)
                .frame(width: 14, height: 14)
        case .completed:
            Image(systemName: "checkmark.circle.fill")
                .font(.system(size: 12))
                .foregroundStyle(ColorSystem.success)
        case .failed:
            Image(systemName: "xmark.circle.fill")
                .font(.system(size: 12))
                .foregroundStyle(ColorSystem.error)
        }
    }

    @ViewBuilder
    private var metadataView: some View {
        HStack(spacing: 4) {
            if let toolUses = content.toolUses {
                Group {
                    Text("·")
                    Text("\(toolUses) tool use\(toolUses == 1 ? "" : "s")")
                }
                .font(Typography.terminalSmall)
                .foregroundStyle(ColorSystem.textTertiary)
            }

            if let tokens = content.outputTokens {
                Group {
                    Text("·")
                    Text(formatTokens(tokens))
                }
                .font(Typography.terminalSmall)
                .foregroundStyle(ColorSystem.textTertiary)
            }
        }
    }

    private var statusText: String {
        switch content.status {
        case .running: return "Running"
        case .completed: return "Done"
        case .failed: return "Failed"
        }
    }

    private var statusColor: Color {
        switch content.status {
        case .running: return ColorSystem.primary
        case .completed: return ColorSystem.success
        case .failed: return ColorSystem.error
        }
    }

    private func formatTokens(_ tokens: Int) -> String {
        if tokens >= 1000 {
            return String(format: "%.1fk tokens", Double(tokens) / 1000)
        }
        return "\(tokens) tokens"
    }
}
// MARK: - Write Tool Enhanced View

/// Enhanced Write tool display with content preview
/// Shows: ● Write(file_path) with collapsible content preview
struct WriteToolElementView: View {
    let content: ToolCallContent
    var searchText: String = ""
    @State private var isExpanded = false

    private let previewLineCount = 5

    /// Get file extension for icon and syntax
    private var fileExtension: String {
        if let path = content.params["file_path"] {
            return (path as NSString).pathExtension.lowercased()
        }
        return ""
    }

    /// File type icon
    private var fileIcon: String {
        switch fileExtension {
        case "swift": return "swift"
        case "md", "markdown": return "doc.text"
        case "json": return "curlybraces"
        case "py": return "sparkles"
        case "js", "ts": return "curlybraces"
        case "html": return "globe"
        case "css": return "paintbrush"
        default: return "doc"
        }
    }

    /// File type color
    private var fileColor: Color {
        switch fileExtension {
        case "swift": return Color(hex: "#F05138")
        case "md", "markdown": return Color(hex: "#083FA1")
        case "json": return Color(hex: "#A5D6FF")
        case "py": return Color(hex: "#3776AB")
        case "js", "ts": return Color(hex: "#F7DF1E")
        default: return ColorSystem.textTertiary
        }
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 2) {
            // Header: ● Write(file_path)
            headerView

            // Content preview (collapsible)
            if let writeContent = content.fullContent, !writeContent.isEmpty {
                if isExpanded {
                    contentPreview(writeContent)
                        .transition(.opacity.combined(with: .move(edge: .top)))
                } else {
                    contentSummary(writeContent)
                }
            }
        }
        .padding(.vertical, Spacing.xxs)
        .frame(minHeight: 20)
    }

    private var headerView: some View {
        Button {
            if content.fullContent != nil {
                withAnimation(Animations.stateChange) {
                    isExpanded.toggle()
                }
                Haptics.selection()
            }
        } label: {
            HStack(alignment: .top, spacing: Spacing.xxs) {
                // Status indicator
                Circle()
                    .fill(statusColor)
                    .frame(width: 6, height: 6)
                    .padding(.top, 5)

                // Expand/collapse chevron (matches Update tool layout)
                if content.fullContent != nil {
                    Image(systemName: isExpanded ? "chevron.down" : "chevron.right")
                        .font(.system(size: 8, weight: .semibold))
                        .foregroundStyle(ColorSystem.textQuaternary)
                        .padding(.top, 5)
                }

                // File icon
                Image(systemName: fileIcon)
                    .font(.system(size: 10, weight: .medium))
                    .foregroundStyle(fileColor)
                    .padding(.top, 4)

                // Tool display: Write(file_path)
                Group {
                    if searchText.isEmpty {
                        Text(toolDisplay)
                    } else {
                        HighlightedText(toolDisplay, highlighting: searchText)
                    }
                }
                .font(Typography.terminal)
                .foregroundStyle(ColorSystem.Tool.name)
                .lineLimit(2)
                .fixedSize(horizontal: false, vertical: true)

                Spacer(minLength: 0)

                // Running spinner
                if content.status == .running {
                    ProgressView()
                        .scaleEffect(0.6)
                        .tint(ColorSystem.primary)
                }
            }
        }
        .buttonStyle(.plain)
    }

    private var toolDisplay: String {
        if let path = content.params["file_path"] {
            return "Write(\(path))"
        }
        return "Write"
    }

    private var statusColor: Color {
        switch content.status {
        case .running: return ColorSystem.info
        case .completed: return ColorSystem.primary
        case .error: return ColorSystem.error
        case .interrupted: return ColorSystem.warning
        }
    }

    @ViewBuilder
    private func contentSummary(_ fullContent: String) -> some View {
        let lines = fullContent.components(separatedBy: "\n")
        let previewText = lines.prefix(previewLineCount).joined(separator: "\n")
        let hasMore = lines.count > previewLineCount

        VStack(alignment: .leading, spacing: 2) {
            HStack(alignment: .top, spacing: Spacing.xxs) {
                Text("⎿")
                    .font(Typography.terminal)
                    .foregroundStyle(ColorSystem.textQuaternary)

                Text(previewText)
                    .font(Typography.terminalSmall)
                    .foregroundStyle(ColorSystem.textSecondary)
                    .lineLimit(previewLineCount)

                Spacer(minLength: 0)
            }

            if hasMore {
                HStack(spacing: Spacing.xxs) {
                    Text("…")
                        .font(Typography.terminal)
                        .foregroundStyle(ColorSystem.textQuaternary)

                    Text("+\(lines.count - previewLineCount) lines (tap to expand)")
                        .font(Typography.terminalSmall)
                        .foregroundStyle(ColorSystem.textQuaternary)
                }
                .padding(.leading, Spacing.sm)
            }
        }
    }

    @ViewBuilder
    private func contentPreview(_ fullContent: String) -> some View {
        VStack(alignment: .leading, spacing: 0) {
            // Full content in scrollable code block
            ScrollView(.horizontal, showsIndicators: false) {
                Group {
                    if searchText.isEmpty {
                        Text(fullContent)
                    } else {
                        HighlightedText(fullContent, highlighting: searchText)
                    }
                }
                .font(Typography.terminalSmall)
                .foregroundStyle(ColorSystem.textPrimary)
                .textSelection(.enabled)
                .fixedSize(horizontal: true, vertical: true)
                .padding(Spacing.sm)
            }
            .frame(maxHeight: 300)  // Limit height for very long files
            .background(ColorSystem.terminalBgHighlight)
            .clipShape(RoundedRectangle(cornerRadius: CornerRadius.small))

            // Collapse button
            Button {
                withAnimation(Animations.stateChange) {
                    isExpanded = false
                }
                Haptics.selection()
            } label: {
                Text("collapse")
                    .font(Typography.terminalSmall)
                    .foregroundStyle(ColorSystem.textQuaternary)
            }
            .padding(.top, Spacing.xxs)
            .padding(.leading, Spacing.sm)
        }
        .padding(.leading, Spacing.sm)
    }
}
